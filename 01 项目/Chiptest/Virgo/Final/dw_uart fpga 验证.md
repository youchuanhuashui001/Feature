# 寄存器分析
[[dw_uart ip]]


# 驱动分析


## 测试 case 和测试用例分析：

## gxloader

### 测试用例：
- 测试 DMA 传输功能：
	- dw_uart. c 文件开头的 `ENABLE_UART_DMA_TEST` 宏打开
	- `getc、putc` 都会使用 dma
- 测试奇/偶校验：
	- #virgo_q 执行测试步骤 4？没地方写
	- 没有测试代码
- 测试发送中断：
	- #virgo_q 代码里面中断相关用的都是 rx 啊
- 测试发送硬件 FIFO 大小：
	- #virgo_q 测试代码为什么注释掉了？
	- `uarttest tx_fifo_size`
- 测试多种波特率：
	- 打开两个串口，一个是交互串口，一个是待测试串口
	- 交互串口用于启动，停止测试
	- 待测试串口用于修改不同的波特率来查看打印是否正确
- 测试小数波特率：
	- `dw_uart.c` 中定义了 `DW_UART_FRACTIONAL_BAUD_DIV`，打开后就会使用小数波特率
	- #virgo_q 怎么判断小数波特率是不是更准？
- 测试接收中断：
	- 打开 `CONFIG_ENABLE_IRQ、CONFIG_ENABLE_UART_IRQ`
- 测试接收硬件 FIFO 大小：
	- `uarttest rx_fifo_size`
- 测试接收硬件 FIFO 溢出检测：
	- #virgo_q 怎么伪造出这个中断？
- 测试硬件流控 CTS：
	- 配置待测试串口为终端
	- CTS 管脚接到 3.3V 上时，确认串口是否能正常输出  
	- CTS 管脚接到 GND 上时，确认串口是否能正常输出
- 测试硬件流控 RTS：
	- 配置待测试串口为终端
	- 通过 GDB 加载程序，程序启动后将程序暂停运行 (CTRL + C)  
	- 确认此时 RTS 管脚的电平  
	- PC 端向控制台持续输入字符  
	- 当 RX FIFO 接近满的时候 (剩余 2 个字节)，确认 RTS 管脚的电平  
	- 将 RX FIFO 中的数据取出 (剩余超过 2 个字节)，确认 RTS 管脚的电平
- 测试波特率检测功能：
	- `uart_brc_test [port]`
- 测试串口长时间收发：
	- 没找到测试代码
- 测试波特率和实际波特率偏差：
	- `uart_brc_test [port]`


### 测试代码：
- baudrate：测试不同的波特率是否可正常工作
	- 测试波特率范围从 9600 ~ 1500000
	- 显示当前要测试的波特率，等待用户按 Enter 开始
	- 将要测试的串口初始化为指定的波特率
	- 循环发送测试字符串：`i can speek english\r\n`
	- 每次发送后延时 1s
	- 当用户在串口输入 `c` 表示结束测试
	- 结束测试前将待测试的串口波特率配置为 115200
- tx_fifo_size: 测试串口 tx fifo 缓冲区的实际大小
	- 停止 tx fifo，不要传输数据
	- 往 tx fifo 持续填充字符
	- 获取 tx fifo 中的数据量，直到 fifo 中的数量达到最大容量
	- 恢复 tx fifo，可以传输数据
	- #virgo_q : 这段代码为什么注释掉了？
- rx_fifo_size: 测试串口 rx fifo 缓冲区的实际大小
	- 实时监测串口 rx fifo 的使用情况
	- #virgo_q ：哪里往 fifo 放数据？
- flow_cts: 测试串口 cts 硬件流控
	- cts 用于告知发送方是否可以发送数据；接收方准备好接收数据时，会将 cts 信号置为有效；否则置为无效；
	- 计数器初始化为 0
	- 启动串口的流控
	- 持续发送字符 `A`，每 16 个字符发一个换行符
	- 我这边作为主机一直发一直发，从机没准备好处理数据，会拉低 cts
	- #virgo_q ：这里是要看下 cts 的波形就行了？从机是独立的小板吗？
- flow_rts:
	- rts 是接收方用来控制发送方的信号；接收方准备好接收数据时，会将 RTS 置为有效；否则无效
	- 启用流控
	- 循环接收 128 个字符
	- 每接收一个字符后延时 2s
	- #virgo_q ：这里也是看下 rts 的波形？应该还有另一块小板？这里是模拟接收方来不及接收数据的情况？让 rts 有效？
- uart_brc_test: 用来测试串口波特率
	- 启动 brc 测试
	- 如果检测到了，计算频率
	- #virgo_q ：另一块板子一直发 0xef






## ecos

## linux









# 注意 