
# 测试用例
## 功能测试：
### 输出位宽测试：
- 测试步骤：
	- 准备测试数据
	- 分别配置传输模式为固定长度模式和无尽模式 
	- 依次设置有效位宽为：2bit、4bit、8bit、16bit
	- 启动传输
- 预期结果：
	- 数据能够按照配置的位宽正确传输
### 固定长度传输测试：
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为固定长度传输
	- 依次设置传输长度为一组、两组、三组和四组地址长度寄存器对
	- 启动传输
- 预期结果：
	- 数据传输至最后一组地址长度寄存器对后，自动跳转到第一组，循环继续传输
	- 传输完指定长度数据后自动停止
### 无尽传输模式测试：
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为无尽传输模式 
	- 依次设置传输长度为一组、两组、三组和四组地址长度寄存器对
	- 启动传输
- 预期结果：
	- 持续传输数据
### 两次传输间的发送延时测试：
- 测试步骤：
	- 准备测试数据 
	- 配置传输模式为固定或无尽传输模式
	- 配置两次传输间的延时时间
	- 启动传输
- 预期结果：
	- 两次传输之间的时间间隔与配置的延时时间一致

### tx_done 中断测试
- 测试步骤：
	- 准备测试数据 
	- 配置传输模式为固定长度传输模式
	- 使能 tx_done 中断
	- 启动传输
- 预期结果：
	- 数据传输完成后触发 tx_done 中断 

### fifo_empty 中断测试
- 测试步骤：
	- 准备测试数据 
	- 配置传输模式为固定或无尽传输模式
	- 使能 fifo_empty 中断
	- 启动传输 
- 预期结果：
	- 触发 fifo_empty 中断 

### fifo_full 中断测试
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为固定或无尽传输模式
	- 使能 fifo_full 中断
	- 启动传输
- 预期结果：
	- 触发 fifo_full 中断

### dmalite timeout 中断测试
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为固定或无尽传输模式
	- 使能 timeout 中断
	- 启动传输
- 预期结果：
	- 触发 timeout 中断

### dmalite ahb response error 中断测试
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为固定或无尽传输模式
	- 使能 ahb response err 中断
	- 启动传输
- 预期结果：
	- 触发 ahb response err 中断

### dmalite 传输完成中断测试
- 测试步骤：
	- 准备测试数据 
	- 配置传输模式为固定或无尽传输模式
	- 使能四组的传输完成中断
	- 启动传输 
- 预期结果：
	- 触发四组的传输完成中断 

### 当前传输情况获取测试
- 测试步骤：
	- 准备测试数据
	- 配置传输模式为固定或无尽传输模式 
	- 启动传输
	- 查询当前传输情况
- 预期结果：
	- 能够准确获取当前正在传输的寄存器组和传输请求次数

# 测试代码


### dmalite 的特性中：可以通过参数例化配置有效数据位宽，目前不可配 
- 不用管，dmalite 是一个通用的模块，iodma 里面用不上，也就测不到 

### IODMA_TX_DELAY：在数据发送到 IO 上之后，下次发送数据需要等待的时间
- 对于单线、四线、八线、十六线，指的是发出来一次波形等待的时候 (由于波形会维持原来的 io 状态，所以表现为维持这个波形多长时间)
- 对于 32bit 的一个 word 数据，8 线会发 4 次，每次都会等待这个时间；4 线会发 8 次，每次都会等待这个时间。
#### 无尽模式
- 配置为 1：
![[Pasted image 20250118140000.png]]
- 配置为 0xfffff：
![[Pasted image 20250118140020.png]]

#### 固定模式

##### 4 线：
- 配置为 0xfffff
![[Pasted image 20250118141416.png]]
##### 8 线
- 配置为 1：
![[Pasted image 20250118141107.png]]
- 配置为 0xfffff: 时钟不知道是多少，假如是 32MHz 的话就对得上了
![[Pasted image 20250118140726.png]]



# 测试 case

> [!info]
> - 没法测到多组的 dmalite 寄存器对
> 	- 固定模式：
> 		 - 将  single 最大的传输长度配置短一点，这样就可以测到多组 dmalite 寄存器对
> 		 - 配置 single 为 100，传 101、150、200 测到两组寄存器对，传输 ok
> 		 - 配置  single 为 100，传 201、250、300 测到三组寄存器对，传输 ok
> 		 - 配置  single 为 100，传 301、350、400 测到四组寄存器对，传输 ok
> 		 - 配置 single 为 0x10，iodma_tx_delay 为 20ms，传  0x41、0x50、0x51、0x60、0x61、0x70、0x71、0x80、0x94、0x132 测到循环寄存器对，传输 ok
> 	 - 无尽模式：
> 		 - 将 single 最大的传输长度配短一点，测试多组 dmalite 寄存器对
> 		 - 单组：0x4
> 		 - 双组：0x11
> 		 - 三组：0x21
> 		 - 四组：0x40
> - 没法测到 dmalite 的 ahb response err 中断 
> - 没有获取当前传输情况的函数 

# 功能测试
- 有效数据位宽：2bit、4bit、8bit、16bit
- 固定传输模式：一组、两组、三组、四组寄存器对；  循环配置；
- 无尽传输模式：一组、两组、三组、四组寄存器对
- 两次传输见的延时测试：IODMA_TX_DELAY
- 查询当前传输情况：
- 中断测试：


# 测试 case：

- 手动修改 single 的传输长度为 0x100
- 执行 iodma comtest
- 没有覆盖到 get index、dmalite 的 ahb response error、iodma 的 fifo full、fifo empty 中断 
	- 访问超过 sram 大小的地址，会产生 ahb response error



> [!faq] 为什么在大于传输长度之后有时候传的数据是错的？假如单组最多 0x100，传输 0x501 发现后面的数据是错的
> > [!todo]  因为 dmalite 传的太快了，中断里面还没更新寄存器就已经传完了，把 tx_delay 配大点就好了，或者 single 传多点 


- 手动测试：
	- tx_delay 配大一点  20000
	- 固定长度：单组、两组、三组、四组、循环
	- 无尽长度：单组、两组、三组、四组 
		- 长度比较长的时候不好看数据，可以用 `gdb call memset(&test_buffer, 0xff, len)` 来手动修改 buffer，这样就可以从波形很好看出来了