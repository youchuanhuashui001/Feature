## 特性：

### 2.1 UART (RS232) 串行协议
- Designware Uart 与所选设备之间的通信是异步的，因此将附加位(Start/Stop)添加到序列数据中用于指示开始和结束。
![[Pasted image 20250210142132.png]]
- 可以将额外的奇偶校验位添加到串行字符中。奇偶校验位出现在最后一个数据位和停止位之前。
- **Line Control Register (LCR) 寄存器用于控制串行字符特征。** 数据位在 Start 位之后开始发送，顺序是 LSB，最先发最低位。随后是奇偶校验位、停止位 (可以是 1、1.5、2).
- 传输时所有位的传输时间完全相同。
	- 例外情况：使用 1.5 位的 stop 位时的 `half-stop bit`。此持续时间称为 Bit Period 或 Bit Time。1 位时间为 16 个波特时钟。
- 为了确保线路的稳定性，一旦检测到起始位，接收器就会在大约 Bit Time 的中点对串行输入数据进行采样。因为知道传输每个 bit 的波特率的准确值，所以计算采样的中点也很方便。
![[Pasted image 20250210142853.png]]


### 2.2 9bit 数据传输
- Designware uart 可以配称为在发送和接收模式下进行 9 位数据传输。字符中的第 9 位在第 8 位之后，奇偶校验位之前。
![[Pasted image 20250210143417.png]]
- 通过启用第 9 位数据传输模式，可以将 dw-uart 用于一个主设备连接到多个从设备的多点系统。主设备与其中的一个从设备通信。当 master 想要将数据发到 slave 时，先发一个地址字节来识别目标 slave。如果第 9 位设为 0，则该字符是数据字节；如果是 1，则该字符是地址字节。所有 slave 会将地址字节与自己的地址进行比较，并且只有匹配成功才能从 master 接收数据，然后 master 开始向 slave 发送数据字节。未匹配成功的 slave 会忽略数据，直接接收新的地址字节。

- 配置 9 位数据传输的 dw-uart 执行以下操作：
	- `LCR_EXT[0]` 用于启用或禁用 9 位数据传输
	- `LCR_EXT[1]` 用于在接受的情况下选择基于硬件和软件的地址匹配
	- `LCR_EXT[2]` 用于在发送的情况下启用发送地址
	- `LCR_EXT[3]` 用于在基于硬件和原件的地址传输之间进行选择
	- `TAR、RAR` 寄存器分别用于发送地址和匹配接收到的地址
	- `THR、RBR、STHR、SRBR` 寄存器是 9 位寄存器，用于在 9 位模式下进行数据传输
	- `LSR[8]` 用于表示接收到的中断地址 

#### 传输模式 1
#### 接收模式



### 2.3 RS485 串行协议


### 2.4 分数波特率支持
- dw-uart 支持小数波特率，使用户能够对除数值的小数部分进行编程，以生成小数波特率，从而减少频率误差。
- dw-uart 的波特率由异步串行时钟 `CLOCK_MODE=2` 实现中的 `sclk` 或单时钟 `CLOCK_MODE=1` 中的 `pclk` 和出书锁存寄存器 `DLH、DLL` 控制。
	- **目前用的是 `CLKCO_MODE=1`**
- 波特率由以下因素决定：
	- 串行时钟工作频率 (模块频率)
	- 所需的波特率
	- 波特率发生器除数值，`DIVISOR (DLH、DLL 组成)` 
	- 可接受的波特率误差 `%ERROR` 
- 计算波特率的公式如下：
![[Pasted image 20250210145829.png]]
- 配置小数波特率执行如下操作：
	- 配置参数 `DLF_SIZE` 用于选择存储除数小数部分的寄存器宽度
	- 除数的小数编程在 `DLF` 寄存器。分数值使用 `除数分数值/(2^DLF_SIZE)` 计算得到 
	- 以下显示 `DLF_SIZE = 4` 时的分数值：
![[Pasted image 20250210150106.png]]

- example：
	- 所需波特率 (RBR) = 4454400
	- 串行时钟 (SCLK)  = 133MHz
	- DLF_SIZE = 4
![[Pasted image 20250210151001.png]]


### 2.5 IrDA 1.0 SIR Protocol




### 2.6 FIFO Support
- 可以配置 DW_apb_uart 来实现用于缓存发送和接收数据的 FIFO，如图 1-2 所示。如果没有选择 FIFO 支持，则不会实现 FIFO，此时在 RBR 和 THR 寄存器中一次只能存储一个接收数据字节和一个发送数据字节；这意味着是一种与 16450 兼容的操作模式。然而，在这种操作模式下，大多数增强功能都不可用。
- 在 FIFO 模式下，可以选择 FIFO 为以下任一值：
	- 外部客户提供的 FIFO RAM
	- Designware 内部的基于 D 触发器的 RAM
- 如果配置的 FIFO 深度大于 256，则 FIFO 内存选择限制为外部。此外，选择内部存储器会将内存读端口类型限制为基于 D 触发器的
- 如果配置的 FIFO 深度大于 256，FIFO 存储器的选择必须限制为外部存储器。此外，选择内部存储器会将存储器读取端口类型限制为基于 D 触发器的同步读取端口 RAM。
	- 当选择外部 RAM 支持时，可以使用同步或异步 RAM。
	- 异步 RAM 在存储器地址和读信号有效的时钟周期内提供读取数据，并在下一个时钟上升沿进行采样。
	- 同步单级 RAM 会将当前地址的数据寄存，直到下一个时钟周期才能使用；也就是说，要等到第二个时钟上升沿。
![[Pasted image 20250210152732.png]]
![[Pasted image 20250210152751.png]]
- 选择 FIFO 支持时，可选的可编程 FIFO 访问模式可用于测试目的，它允许：
	- 接收 master 写入的 FIFO
	- 发送 FIFO 以供 master 读取
- 当未选择 FIFO Access 模式时，不会实现任何相应的逻辑，并且无法启用该模式，从而减少总门数。
- 当选择 FIFO Access 模式时，可以使用 `FAR[0]` 启用，起哟你够发送和接收 FIFO 的控制部分将被重置，并且 FIFO 被视为空。
	- 数据可以正常写入 TX FIFO，但这种模式下并没有发生串行传输，正常操作停止，已写入 TX FIFO 的数据可以从 `TFR` 寄存器读回，该寄存器在读取时在 `TX FIFO` 的顶部提供当前数据
	- 可以像往常从 RX FIFO 读取数据，由于在此模式下正常操作停止，因此必须将数据写入 Receive FIFO，以便读回数据
	- 使用 `RFW` 寄存器将数据写入接收 FIFO。10 位寄存器中的高两位用于将帧错误、奇偶校验错误监测信息写入接收 FIFO：
		- `RFW[9]` 表示帧错误
		- `RFW[8]` 表示奇偶校验错误
	- 这些为不能通过 `RBR` 读回，但当相关数据位于 `RX FIFO` 的顶部时，可以通过读取 `LSR` 并检查相应的位来检查它们 



### 2.7 时钟支持
- dw-uart 可以配置为具有一个系统时钟 `pclk` 或两个系统时钟 `pclk + sclk`。`sclk` 支持精确的串行波特率设置以及 APB 总线接口要求。当使用单系统 clk 时，可用的系统时钟设定精准波特率受到很大限制。
- 当选择双时钟设计时，会实现一个同步模块，用于在两个系统时钟域边界上同步所有控制信号和数据




### 2.8 背对背字符流传输
- dw-uart 能够在串行传输接口上传输背靠背字符，并且它们之间没有空闲时间的场景
- 背靠背角色之间存在的最坏情况空闲时间会在下面介绍

- 当 TXFIFO 包含多个数据条目时，dw-uart 在串行总线上背靠背传输 FIFO 中的字符。但是，如果 `CLOCK_MODE`  配置为2，则 dw-uart 中的同步延迟可能会导致当前 STOP 位的末尾和下一个 START 位的开始之间出现 IDLE 周期，这在串行总线上显示为演唱的 STOP bit 持续时间。



#### 双时钟模式
- 当 `CLOCK_MODE = 2`



#### 单时钟模式
- 当 `CLOCK_MODE = 1`，如果 `TX FIFO` 已准备好数据，则背对背字符之间没有空闲时间。在这种情况下，由于 `sync_delay == Dual Clock Mode 中的 1 个 pclk`，因此所有 `DLH、DLL` 值都满足避免连续字符之间空闲时间的要求。
	-  `sync_delay <= {DLH,DLL} * sclk`
- 例如：当 `DLH、DLL == 1` 时，(请记住，当 CLOCK_MODE = 1 时，pclk = sclk)，则：
	- `1 pclk <= 1 * pclk`



### 2.9 中断
- dw-uart 中断输出信号 `intr` 的置位为：正电平中断，只要启用并激活了几种优先中断类型之一，就会发生。
- 当中断发生时，主设备访问 IIR 寄存器。
- 可以使用 IER 寄存器启用一下中断类型：
	- 接收错误
	- 可用的接收数据
	- 字符超时 (仅在 FIFO 模式下)
	- 发送保存寄存器等于或小于阈值为空 (在可编程 THRE 中断模式)
	- 调制解调器状态
	- 忙碌检测指示



### 2.10 自动流控
- **如果未实现 FIFOs，则无法选择此模式**
- 当未选择 Auto Flow Control 时，不会实现任何相应的逻辑，并且无法启用该模式，从而减少总门数。
- 当选择 Auto Flow Control 时，可以通过 `MCR[5]` 来启用

![[Pasted image 20250210164554.png]]
![[Pasted image 20250210164609.png]] 
- 自动 RTS 和自动 CTS 说明如下：
	- Auto RTS：
		- 在配置期间选择了 Auto Flow Control
		- FIFOs 实现了
		- RTS (`MCR[1]、MCR[5]` 均已设置)
		- FIFOs 已启用 (`FCR[0]` 设置)
		- SIR 模式禁用 (`MCR[6]` 未设置 )
		- **启用自动 RTS 后，当 `RX FIFO` 的数据等级达到 `FCR[7:6]` 设置的阈值时，`rst_n` 输出被强制停止 (拉高)**，但前提是 `RTC` 流控触发器被禁止。否则，当 FIFO 几乎满时，`rts_n` 输出被强制拉高。**当 `rst_n` 连接到另一个 uart 的 `cts_n` 时，另一个 `uart` 停止发送串行数据，直到 `rx fifo` 有可用空间；也就是说，直到它完全清空**
		- 可选的 rx fifo 阈值：
			- 1
			- 1/4
			- 1/2
			- 2 less than full
		- **一旦 rxfifo 通过读取 `RBR` 直到 FIFO 完全为空，则 `rst_n` 再次变为有效 (低电平)，向另一个 uart 发出信号指示继续发送数据 **
	- Auto CTS：
		- 在配置期间选择了 Auto Flow Control
		- FIFOS 实现了
		- AFCE (`MCR[5]` 设置为 1)
		- FIFO 已启用 (`FCR[0]` 设置)
		- SIR 模式禁用 (`MCR[6]` 未设置 )
		- 启用自动 CTS 后，每当 `cts_n` 变为非活动状态 (高电平)，dw-uart 就会禁用 tx；这可以防止接收 uart 的 fifo 溢出
		- 如果 `cts_n` 输入在最后一个停止位的中间之前未停用，则会在禁用 tx 之前传输另一个字符。当 tx 被仅用时，tx fifo 仍可以写入，甚至溢出。



### 2.11 可编程 THRE 中断
dw-uart 可配置为可编程 THRE 中断模式，以提高系统性能；如果未实现 FIFOs，则无法选择此模式。
- 当未选择 THRE 中断模式时，不会实现任何逻辑，并且无法启用，从而减少门数
- 当选择 THRE 中断模式，可以使用中断启用寄存器 `IER[7]` 启用
当 FIFO 和 THRE 模式实现并启用时，THRE 中断和 dma_tx_req_n 在编程的 TXFIFO 空阈值电平及以下状态处于活动状态，而不是空

- **和 spi 类似，配置一个阈值，FIFO 的值少于这个阈值就认为是 FIFO Empty**


![[Pasted image 20250210165344.png]]


### 2.12 Clock Gate Enable





### 2.13 DMA 支持
![[Pasted image 20250210204257.png]]
- **和 spi 类似，对于 tx 数据从 sram 搬到 tx fifo；对于 rx 数据从 rx fifo 搬到 sram**

- dma_rx_req_n   --> fifo 有数据需要取走到 sram
- dma_tx_req_n  --> fifo 没有数据发送，需要从 sram 搬到 fifo

#### DMA 模式
`DW_apb_uart` 使用两个 `DMA` 通道，一个用于传输数据，一个用于接收数据。有两种 `DMA` 模式：
- 模式 0：`FCR[3] == 0` 
	- 当 FIFOs 未实现或禁用时，只有模式 0 可用
- 模式 1：`FCR[3] == 1`


##### DMA 模式 0
DMA 模式 0 支持单次传输单个 dma 数据。
在模式 0，`dma_tx_req_n` 信号：
- 在以下情况为低电平有效：
	- 在非 FIFO 模式下，THR 寄存器为空
	- 在 FIFO 模式下，`tx fifo` 为空且可禁止可编程 `THRE` 中断模式
	- 当 `tx fifo` 等于或低于编程阈值，并且启用可编程 `THRE` 中断模式 
- 在以下情况下为非活动状态：
	- 单个字符已写入 `THR 或 tx fifo`，可编程 THRE 中断模式禁用
	- `tx fifo` 高于阈值，且启用可编程 THRE 中断模式

> [!info]
> - 有效：
> 	- 非 fifo 模式，THR 寄存器为空。此时 tx fifo 没有数据需要 dma 从 sram 搬数据到 tx fifo
> 	- fifo 模式，没开阈值时 THR 为空。开了阈值，tx fifo 等于或小于阈值。
> - 无效：
> 	- 单个字符写到了 THR
> 	- tx fifo 大于阈值

在模式 0，`dma_rx_req_n` 信号：
- 当 `rx fifo` 或 `RBR` 寄存器中有单个字符可用时，变为低电平有效
- 当 `RBR` 寄存器或 `rx fifo` 为空时变为非活动状态，具体取决于 FIFO 模式

##### DMA 模式 1
DMA 模式 1 支持多 DMA 数据传输，其中连续进行多次传输，直到 `rx fifo` 被清空或 `tx fifo` 被填满。

- `dma_tx_req_n` 信号被置位：
	- `tx fifo` 为空，`THRE` 没开的时候
	- `tx fifo =/< 编程阈值`，`THRE` 开着的时候
- 当 `tx fifo` 完全满时，`dma_tx_req_n` 信号无效。

- `dma_rx_req_n` 信号被置位：
	- `rx fifo` 处于或高于编程的触发等级时
	- 发生字符超时时；不需要设置 `ERBFI`
- 当 `rx fifo` 变为空时，`dma_rx_req_n` 信号无效。


#### 附加 DMA：外部 dma
[[dw_spi控制器#^4f33e0]]
- 可以使用参数 `DMA_EXTRA` 来为 `dw-uart` 配置额外的 DMA 接口信号。在这种情况下，`dma_tx_req_n/dma_rx_req_n` 和 DMA 模式 0、DMA 模式 1 中详述的情况类似。
- 由于存在附加的握手信号，UART 不必依赖内部状态和级别来识别请求的完成并因此移除请求。相反，DMA 发送和接收请求的撤销分别由 DMA 发送和接收应答来控制。
- 当 UART 配置为附加 DMA 信号时，数据流 (传输长度) 的责任落在 `DMA(dw-ahb-dmac)` 身上，并由已变编程的突发传输长度控制。**因此，不再需要 DMA 模式，且编程 `FCR[3]` 无效。**

##### 发送水线和 TX FIFO 下溢
- 在 `dw-uart` 串行传输期间，只要 `tx fifo <= FCR.TET  bit[5:4]` 就会向 `DW_ahb_dmac` 发出发送 FIFO 请求。这称为水线级别。`DW_ahb_dmac` 通过将 burst 数据写入长度为 `CTLx.DEST_MSIZE` 的 `tx fifo` 来响应。
- 一般发送水线配置为与 Burst 宽度一致：`FCR[5:4] = 8   == DMA.CTLx.DEST_MSIZE

##### 接收水线和 RX FIFO 上溢 
- 在 `dw-uart` 串行传输期间，只要 `rx fifo >= FCR.RT  bit[7:6]` 就会向 `DW_ahb_dmac` 发出接收 FIFO 请求。这称为水线级别。`DW_ahb_dmac` 通过从长度为 `CTLx.SRC_MSIZE` 的 `rx fifo` 获取 burst 数据来相应。
- 一般接收水线配置为与 Burst 宽度一致：`FCR[7:6] == 8 == DMA.CRLx.SRC_MSIZE` 

![[Pasted image 20250211110202.png]]

![[Pasted image 20250211110430.png]]

![[Pasted image 20250211110455.png]]



### Reset 信号


# 寄存器 
## RBR：Receive Buffer Register
- Name：接收缓冲区寄存器
- 描述：接收缓冲区寄存器
	- **仅当清除 `DALB位  LCR[7] == 0` 时，才可以访问此寄存器**
- Size：32bits
- Offset：0x0
- Exists：永远 

| Bits | Name | Memory Access | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ---- | ---- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| x:0  | RBR  | R             | 接收缓冲区寄存器。<br>此寄存器包含在 UART 模式下的串行输入端口 (SIN) 上接收到的数据字节，或以红外模式以串行红外输入 (SIR_IN) 接收到的数据字节。仅当设置了 `LSR` 寄存器中的 `DR` 位时，此寄存器中的数据才有效。<br>**如果在非 FIFO 模式 (FIFO_MODE == NONE) 或 FIFOS 被禁用 `(FCR[0] == 0)`，则必须在下一个数据到达之前读取 RBR 中的数据。**否则将会覆写，产生错误。<br>**如果在 FIFO 模式 (FIFO_MODE != NONE) 或 FIFOS 被启用 `(FCR[0] == 1)`，则此寄存器访问接收 FIFO 的头部。**如果接收 FIFO 已满，并且在下一个数据字符到达之前为读取此寄存器，则将保留 FIFO 中的数据，但是任何传入的数据都将丢失，并且发生过度运行错误。<br><br>当 UART_9BIT_DATA_EN = 0，此字段宽度为 8；<br>当 UART_9BIT_DATA_EN = 1，此字段宽度为 9； |


## DLL：Divisor Latch Low Register
- Name：分频器锁存低寄存器
- 描述：分频器锁存低寄存器
	- 如果 `UART_16550_COMPATIBLE = no`，则只有在设置 `LCR[7]` 位并且 UART 并不忙时(`USR[0] == 0`)，才可以访问此寄存器
	- **否则只有在设置 `LCR[7] == 1` 位时，才可以访问此寄存器**
- Size：32bits
- Offset：0x0
- Exists：永远 

| Bits | Name | Memory Access | Description                                                                                                                           |
| ---- | ---- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| x:0  | DLL  | R/W           | 分频器锁存低寄存器。<br>该寄存器构成了 16 位的较低的 8 位，包含 UART 的波特率分频器。**输出波特率等于串行时钟/16*divisor。**<br>如果是一个时钟设计，则串行时钟为 pclk；<br>如果是两个时钟设计，则串行时钟为 sclk<br> |


## THR：Transmit Holding Register
- Name：发送保持寄存器
- 描述：发送保持寄存器
	- **仅当清除 `DALB位  LCR[7] == 0` 时，才可以访问此寄存器**
- Size：32bits
- Offset：0x0
- Exists：永远 

| Bits | Name | Memory Access | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ---- | ---- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| x:0  | THR  | W             | 传输保持寄存器。<br><br><br>这个寄存器包含要通过串行输出端口 (sout) 以 UART 模式或串行红外输出 (sir_out_n) 以红外模式发送的数据。只有当THR 空且(THRE)位 (LSR[5]) 被设置时，数据才应该被写入到 THR。<br><br>如果在非 FIFO 模式或 FIFO 被禁用 (FCR[0] 设置为 0) 且 THRE 被设置，则向 THR 写入单个字符会清除 THRE。在 THRE 再次被设置之前，任何额外的写入 THR 的操作都会导致 THR 数据被覆盖。<br><br>如果在 FIFO 模式且 FIFO 被启用 (FCR[0] 设置为 1) 且 THRE 被设置，则可以在 FIFO 满之前向 THR 写入 x 个字符的数据。 数字 x (默认值=16) 由配置期间设置的 FIFO 深度值决定。 任何尝试在 FIFO 满时写入数据的操作都会导致写入数据丢失。<br><br><br>当 UART_9BIT_DATA_EN = 0，此字段宽度为 8；<br>当 UART_9BIT_DATA_EN = 1，此字段宽度为 9； |

## DLH：Divisor Latch High Register
- Name：分频器锁存高寄存器
- 描述：分频器锁存高寄存器
	- 如果 `UART_16550_COMPATIBLE = no`，则只有在设置 `LCR[7]` 位并且 UART 并不忙时(`USR[0] == 0`)，才可以访问此寄存器
	- **否则只有在设置 `LCR[7] == 1` 位时，才可以访问此寄存器**
- Size：32bits
- Offset：0x4
- Exists：永远 

| Bits | Name | Memory Access | Description                                                                                                                                                                                                                                                                                                                                                                  |
| ---- | ---- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| x:0  | DLL  | R/W           | 16 位读写 **分频锁存寄存器 (Divisor Latch register)** 的高 8 位，该寄存器包含 UART 的波特率分频值。<br><br> 输出波特率等于串行时钟频率 (单时钟设计时为 pclk，双时钟设计 (CLOCK_MODE == Enabled) 时为 sclk) 除以波特率分频值的十六倍，计算公式如下：**波特率 = (串行时钟频率) / (16 * 分频值)**。<br><br> 请注意，当 **分频锁存寄存器 (Divisor Latch Registers) (DLL 和 DLH)** 都设置为零时，波特率时钟被禁用，串行通信将不会发生。此外，一旦设置了 DLH，在发送或接收数据之前，应至少允许最慢的 DW_apb_uart 时钟经过 8 个时钟周期。<br><br><br><br> |

## IER：Interrupt Enable Register
- Name：中断使能寄存器
- 描述：中断使能寄存器
	- **只有在 `LCR[7] == 0` 位时，才可以访问此寄存器**
- Size：32bits
- Offset：0x4
- Exists：永远 

| Bits  | Name   | Memory Access | Description                                                                                                               |
| ----- | ------ | ------------- | ------------------------------------------------------------------------------------------------------------------------- |
| 7     | PTIME  | * Varies      | 可编程 THRE 中断模式使能。只有当 THRE_MODE_USER == Enable 是才可写，始终可读。<br>0: 禁用可编程 THRE 中断模式<br>1: 使能可编程 THRE 中断模式 <br>                  |
| 4     | ELCOLR | * Varies      | 中断启用寄存器：ELCOLR，此位控制清除 LSR 状态寄存器的方法。仅适用于 Overrun 错误、奇偶校验错误、Framing 错误和 Break 中断状态位。<br><br>0: Disable ALC<br>1: Enable ALC |
| 3<br> | EDSSI  | R/W           | 0: 禁止调制解调器状态中断<br>1: 使能调制解调器状态中断                                                                                          |
| 2<br> | ELSI   | R/W           | 0: 禁用接收线状态中断<br>1:  使能接收线状态中断                                                                                             |
| 1     | ETBEI  | R/W           | 使能 THR Empty 中断。<br>0: 禁用 THR 空中断<br>1: 使能 THR 空中断                                                                        |
| 0     | ERBFI  | R/W           | 使能接收数据可用中断。<br>0: 禁用接收数据可用中断<br>1:  使能接收数据可用中断                                                                            |


## FCR：FIFO Control Register
- Name：FIFO 控制寄存器
- 描述：FIFO 控制寄存器
	- **仅当将 `DW_apb_uart` 配置为实现 FIFO 时(fifo_mode != NONE)，此寄存器才有效**
	- **如果未实施 FIFO，则该寄存器降不存在**
- Size：32bits
- Offset：0x8
- Exists：永远 

| Bits  | Name   | Memory Access | Description                                                                                                                                                                                                                                                                       |
| ----- | ------ | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 7:6   | RT     | W             | RCVR 触发器 (或 RT)。这用于选择 rx fifo 中的触发级别。在该触发级别将生成接收数据可用中断。<br>用于确定 `dma_rx_req_n` 信号何时被断言。<br>0: FIFO 中的一个字符<br>1: FIFO 中 1/4 满<br>2: FIFO 中 1/2 满<br>3: FIFO 接近满，还差 2 个满<br><br><br>** RX FIFO 满中断阈值  **                                                                            |
| 5:4   | TET    | * Varies      | **发送空触发 (TX Empty Trigger) (或 TET)**。<br> 当 `THRE_MODE_USER == Disabled` 时，写入操作无效。<br> 此字段用于选择空阈值级别，当达到此级别时，如果模式处于活动状态，将生成 **THRE 中断**。<br>它还决定了在某些操作模式下，何时置位 `dma_tx_req_n` 信号。<br>0: FIFO 空<br>1: FIFO 有两个字符<br>2: FIFO 1/4 满<br>3: FIFO 1/2 满 <br><br><br>** TX FIFO 空中断阈值  ** |
| 3<br> | DMAM   | W             | DMA 模式。如果 `DMA_EXTRA = NO` 用于确定 DMA 模式。<br>0: 模式 0<br>1: 模式 1                                                                                                                                                                                                                     |
| 2<br> | XFIFOR | W             | 1: tx fifo 重置                                                                                                                                                                                                                                                                     |
| 1     | RFIFOR | W             | 1: rx fifo 重置                                                                                                                                                                                                                                                                     |
| 0     | FIFOE  | W             | FIFO 启用。这可以启用/禁用传输并 tx/rx FIFOs。每当更改该位的值时，FIFOs 的 tx rx 控制器端口都重置。<br>0: 禁用 FIFO<br>1: 使能 FIFO                                                                                                                                                                                     |

## IIR：Interrupt Identification Register
- Name: Interrupt Identification Register
- Description: Interrupt Identification Register
- Size: 32 bits
- Offset: 0x8
- Exists: Always

| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_IIR_31to8 | R     | 保留位，读取为 0                                                      |
| 7:6    | FIFOSE         | R     | FIFO 状态指示：<br>0x0: FIFOs 禁用<br>0x3: FIFOs 使能                |
| 5:4    | RSVD_IIR_5to4  | R     | 保留位，读取为 0                                                      |
| 3:0    | IID            | R     | 中断标识，指示最高优先级的待处理中断：<br>0x0: 调制解调器状态<br>0x1: 无待处理中断<br>0x2: THR 空<br>0x4: 接收数据可用<br>0x6: 接收线路状态<br>0x7: 忙检测<br>0xc: 字符超时 |

注意：
- 当 UART_16550_COMPATIBLE = YES 时，忙检测中断(0x7)不会被指示
- Bit 3 仅在 FIFOs 使能时用于区分字符超时中断
- 复位值：0x1

## LCR：Line Control Register 
- Name: Line Control Register  
- Description: Line Control Register
- Size: 32 bits
- Offset: 0xc
- Exists: Always

| 位域   | 名称             | 访问  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ---- | -------------- | --- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 31:8 | RSVD_LCR_31to8 | R   | 保留位，读取为 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 7    | DLAB           | R/W | 除数锁存访问位：<br>0: 禁用 - 除数锁存寄存器只在 UART 空闲时可写<br>1: 使能 - 除数锁存寄存器总是可读写<br>**注：配置波特率后必须清除此位才能访问其他寄存器**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 6    | BC             | R/W | **Break 控制位 (Break Control Bit)** <br><br> 用于使能向接收设备发送中断状态 (break condition)。 如果设置为 1，则串行输出被强制为间隔 (spacing, 逻辑 0) 状态。 当不处于环回模式 (由 MCR[4] 决定) 时，`sout` 线路会被强制拉低，直到 Break 位被清除。 如果 `SIR_MODE == Enabled` 且处于激活状态 (MCR[6] 设置为 1)，则 `sir_out_n` 线路会持续脉冲输出。 当处于环回模式时，中断状态会在内部环回至接收器，并且 `sir_out_n` 线路会被强制拉低。<br><br> **值 (Values):** <br><br> * `0x0` **(DISABLED):** 串行输出被释放用于数据传输 <br><br> * `0x1` **(ENABLED):** 串行输出被强制为间隔 (spacing) 状态 <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是                                                                                                                          |
| 5    | SP             | R/W | **强制奇偶校验 (Stick Parity)** <br><br> 如果 `UART_16550_COMPATIBLE == NO`，则仅当 UART 不忙时（USR[0] 位为 0）可写；否则，始终可写且始终可读。 此位用于强制奇偶校验值。 当 PEN、EPS 和强制奇偶校验位都设置为 1 时，奇偶校验位会作为逻辑 0 发送和检查。 如果 PEN 和强制奇偶校验位设置为 1，而 EPS 为逻辑 0，则奇偶校验位会作为逻辑 1 发送和检查。 如果此位设置为 0，则禁用强制奇偶校验。<br><br> **值 (Values):** <br><br> * `0x0` **(DISABLED):** 强制奇偶校验禁用 <br><br> * `0x1` **(ENABLED):** 强制奇偶校验启用 <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是                                                                                                                                                                                                 |
| 4    | EPS            | R/W | **奇偶校验选择 (Even Parity Select)** <br><br> 如果 `UART_16550_COMPATIBLE == NO`，则仅当 UART 不忙时（USR[0] 位为零）可写；否则，始终可写且始终可读。当奇偶校验被启用时 (PEN 设置为 1)，此位用于在偶校验和奇校验之间进行选择。如果设置为 1，则发送或检查偶数个逻辑 '1'。如果设置为 0，则发送或检查奇数个逻辑 '1'。 <br><br> **值 (Values):** <br><br> * `0x0` **(ODD_PARITY):** 发送或检查奇校验 <br><br> * `0x1` **(EVEN_PARITY):** 发送或检查偶校验 <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是                                                                                                                                                                                                                                   |
| 3    | PEN            | R/W | **奇偶校验使能 (Parity Enable)** <br><br> 如果 `UART_16550_COMPATIBLE == NO`，则仅当 UART 不忙时（USR[0] 位为零）可写；否则，始终可写且始终可读。 此位用于启用和禁用在发送和接收的串行字符中的奇偶校验生成和检测。 <br><br> **值 (Values):** <br><br> * `0x0` **(DISABLED):** 禁用奇偶校验 <br><br> * `0x1` **(ENABLED):** 启用奇偶校验 <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是                                                                                                                                                                                                                                                                                                          |
| 2    | STOP           | R/W | **停止位的数量 (Number of stop bits)** <br><br> 如果 `UART_16550_COMPATIBLE == NO`，则仅当 UART 不忙时（USR[0] 位为零）可写；否则，始终可写且始终可读。 此字段用于选择外围设备将要发送和接收的每个字符的停止位数。 如果设置为零，则在串行数据中发送一个停止位。<br><br> 如果设置为一，并且数据位设置为 5 位 (LCR[1:0] 设置为零)，则发送一个半停止位。 否则，发送两个停止位。 请注意，无论选择的停止位数是多少，接收器都只会检查第一个停止位。<br><br> **注意：** DW_apb_uart 实现的 STOP 位持续时间可能会显得更长，这是由于在某些配置和波特率时钟分频器值的情况下，在字符之间插入了空闲时间； 有关发送传输之间空闲时间的详细信息，请参阅数据手册中“背靠背字符流传输”部分。<br><br> **值 (Values):**<br><br> * `0x0` **(STOP_1BIT):** 1 个停止位<br><br> * `0x1` **(STOP_1_5BIT_OR_2BIT):** 当 DLS (LCR[1:0]) 为零时为 1.5 个停止位，否则为 2 个停止位<br><br> **复位后值 (Value After Reset):** 0x0<br><br> **存在性 (Exists):** 总是 |
| 1:0  | DLS            | R/W | **数据长度选择 (Data Length Select) (或旧称 CLS)** <br><br> 如果 `UART_16550_COMPATIBLE == NO`，则仅当 UART 不忙时（USR[0] 位为零）可写；否则，始终可写且始终可读。 当 LCR_EXT 中的 `DLS_E` 设置为 0 时，此寄存器用于选择外围设备将要发送和接收的每个字符的数据位数。<br><br> **值 (Values):**<br><br> * `0x0` **(CHAR_5BITS):** 每个字符 5 个数据位<br><br> * `0x1` **(CHAR_6BITS):** 每个字符 6 个数据位<br><br> * `0x2` **(CHAR_7BITS):** 每个字符 7 个数据位<br><br> * `0x3` **(CHAR_8BITS):** 每个字符 8 个数据位<br><br> **复位后值 (Value After Reset):** 0x0<br><br> **存在性 (Exists):** 总是                                                                                                                                                          |

注意：
- DLAB 位用于控制波特率寄存器(DLL/DLH)的访问
- 复位值：0x0

## MCR: Modem Control Register
- Name: Modem Control Register
- Description: Modem Control Register  
- Size: 32 bits
- Offset: 0x10
- Exists: Always

| 位域   | 名称             | 访问       | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ---- | -------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 31:7 | RSVD_MCR_31to7 | R        | 保留位，读取为 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 6    | SIRE           | * Varies | SIR 模式使能。<br>仅当 SIR_MODE == Enabled 时可写，始终可读。<br>用于启用/禁用 IrDA SIR 模式功能。<br>注意：要启用 SIR 模式，需要在写入 LCR 寄存器之前向 MCR 寄存器写入适当的值。<br><br>值：<br>0x0 (DISABLED): IrDA SIR 模式禁用<br>0x1 (ENABLED): IrDA SIR 模式使能<br><br>复位值：0x0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 5    | AFCE           | R/W      | 自动流控使能                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 4    | LoopBack       | R/W      | 环回模式使能                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 3    | OUT2           | R/W      | 用户指定输出 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 2    | OUT1           | R/W      | 用户指定输出 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 1    | RTS            | R/W      | **请求发送 (Request to Send)**。 <br><br> 此位用于直接控制 **请求发送 (Request to Send) (rts_n)** 输出。**请求发送 (Request to Send) (rts_n)** 输出用于告知调制解调器或数据装置，UART 已准备好交换数据。 <br><br> **当自动 RTS 流控制未启用时（MCR[5] 设置为零），通过将 MCR[1] (RTS) 编程为高电平，`rts_n` 信号被设置为低电平（有效状态）。在自动流控制模式下，当 AFCE_MODE == 启用且 MCR[5] 设置为 1 并且 FIFO 使能 (FCR[0] 设置为 1) 时，`rts_n` 输出以相同的方式被控制，但同时也会受到接收器 FIFO 阈值触发的门控（当高于阈值时，`rts_n` 信号为非激活高电平）。当 MCR[1] 被设置为低电平时，`rts_n` 信号将被取消置位（变为非有效）。 **<br><br> 请注意，在环回模式下（MCR[4] 设置为 1），`rts_n` 输出被保持为非激活高电平，而此位置的值则在内部环回到一个输入。 <br><br> **值 (Values):** <br><br> * `0x0` **(INACTIVE):** 请求发送 `rts_n` 被取消置位（非有效，逻辑 1） <br><br> * `0x1` **(ACTIVE):** 请求发送 `rts_n` 被置位（有效，逻辑 0） <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是 |
| 0    | DTR            | R/W      | **数据终端就绪 (Data Terminal Ready)**。 <br><br> 此位用于直接控制 **数据终端就绪 (Data Terminal Ready) (dtr_n)** 输出。写入此位置的值会被反转，并驱动到 `dtr_n` 输出引脚。 <br><br>**在自动流控模式下，此寄存器没啥作用**<br><br> **数据终端就绪** 输出用于告知调制解调器或数据装置，UART 已准备好建立通信。 请注意，在环回模式下（MCR[4] 设置为 1），`dtr_n` 输出被保持为非激活高电平，而此位置的值则在内部环回到一个输入。 <br><br> **值 (Values):** <br><br> * `0x0` **(INACTIVE):** `dtr_n` 被取消置位（非有效，逻辑 1） <br><br> * `0x1` **(ACTIVE):** `dtr_n` 被置位（有效，逻辑 0） <br><br> **复位后值 (Value After Reset):** 0x0 <br><br> **存在性 (Exists):** 总是                                                                                                                                                                                                                                            |

注意：
- 复位值：0x0


- **RTS (Request To Send, 请求发送)：** 这是一个 **输出信号线**，由 **数据接收方** (例如，接收数据的 UART) 控制。接收方通过 RTS 信号线 **告知发送方** 是否准备好接收数据。
    - **RTS 低电平 (Low)：** 表示接收方 **准备好** 接收数据，发送方可以发送数据。
    - **RTS 高电平 (High)：** 表示接收方 **繁忙，无法接收** 数据，发送方应该 **暂停** 发送数据。
- **CTS (Clear To Send, 允许发送)：** 这是一个 **输入信号线**，由 **数据发送方** (例如，发送数据的 UART) 监听。 发送方通过 CTS 信号线 **接收来自接收方的流控信息**。
    - **CTS 低电平 (Low)：** 表示接收方 **允许** 发送方发送数据。 (对应接收方的 RTS 为低电平)
    - **CTS 高电平 (High)：** 表示接收方 **不允许** 发送方发送数据。 (对应接收方的 RTS 为高电平)

**硬件自动流控的工作流程 (使用 RTS/CTS 信号线):**

1. **接收方 UART 监测自身接收缓冲区 (FIFO) 的状态。** 当接收缓冲区快要满时 (例如，达到预设的阈值)，接收方 UART 会 **自动将 RTS 信号线拉高 (变为高电平)**。
2. **接收方 UART 的 RTS 信号线连接到发送方 UART 的 CTS 信号线。** 因此，发送方 UART 会检测到 CTS 信号线变为高电平。
3. **发送方 UART 检测到 CTS 信号线为高电平后，会立即暂停数据发送**。
4. **当接收方 UART 的接收缓冲区中的数据被处理 (例如，被 CPU 读取走) 后，接收缓冲区不再拥挤。** 接收方 UART 会 **自动将 RTS 信号线拉低 (变为低电平)**。
5. **发送方 UART 检测到 CTS 信号线变为低电平后，会恢复数据发送**。




## LSR
- Name: Line Status Register
- Description: 线路状态寄存器
- Size: 32 bits
- Offset: 0x14
- Exists: Always

| 位域   | 名称             | 访问  | 描述                                                                                   |
| ---- | -------------- | --- | ------------------------------------------------------------------------------------ |
| 31:9 | RSVD_LSR_31to9 | R   | 保留位，读取为 0                                                                            |
| 8    | ADDR_RCVD      | R   | 地址接收位。<br>**仅当 UART_9BIT_DATA_EN = YES 时存在。**<br>0: 接收到的字符是数据<br>1: 接收到的字符是地址        |
| 7    | RFE            | R   | 接收 FIFO 错误。<br>**仅当 FIFO_ACCESS_MODE = YES 时存在。**<br>0: 无错误<br>1: 至少有一个字符在 FIFO 中有错误 |
| 6    | TEMT           | R   | 发送器空。<br>0: THR/TX FIFO 或 TSR 包含数据<br>1: THR/TX FIFO 和 TSR 都为空                       |
| 5    | THRE           | R   | 发送保持寄存器空。<br>0: THR/TX FIFO 包含数据<br>1: THR/TX FIFO 为空                                |
| 4    | BI             | R   | Break 中断。<br>0: 无 Break<br>1: 检测到 Break                                              |
| 3    | FE             | R   | 帧错误。<br>0: 无帧错误<br>1: 停止位无效                                                          |
| 2    | PE             | R   | 奇偶校验错误。<br>0: 无校验错误<br>1: 校验错误                                                       |
| 1    | OE             | R   | 溢出错误。<br>0: 无溢出错误<br>1: 数据溢出                                                         |
| 0    | DR             | R   | 数据就绪，有新数据可读。<br>0: 无数据<br>1: RBR/RX FIFO 包含数据                                        |

注意：
- 这是一个只读寄存器
- 某些位仅在特定配置下存在
- 复位值：0x60 (THRE 和 TEMT 位置 1)

## MSR
- Name: Modem Status Register
- Description: 调制解调器状态寄存器
- Size: 32 bits
- Offset: 0x18
- Exists: Always

| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_MSR_31to8 | R     | 保留位，读取为 0                                                      |
| 7      | DCD            | R     | 数据载波检测。<br>0: dcd_n 输入为高<br>1: dcd_n 输入为低                |
| 6      | RI             | R     | 振铃指示。<br>0: ri_n 输入为高<br>1: ri_n 输入为低                     |
| 5      | DSR            | R     | 数据集就绪。<br>0: dsr_n 输入为高<br>1: dsr_n 输入为低                 |
| 4      | CTS            | R     | 清除发送。<br>0: cts_n 输入为高<br>1: cts_n 输入为低                   |
| 3      | DDCD           | R     | DCD 信号的 Delta。<br>0: 无变化<br>1: DCD 信号发生变化                 |
| 2      | TERI           | R     | RI 信号的尾迹边缘。<br>0: 无变化<br>1: RI 信号从低变高                  |
| 1      | DDSR           | R     | DSR 信号的 Delta。<br>0: 无变化<br>1: DSR 信号发生变化                 |
| 0      | DCTS           | R     | CTS 信号的 Delta。<br>0: 无变化<br>1: CTS 信号发生变化                 |

注意：
- 这是一个只读寄存器
- Delta 位指示相应信号的变化
- 复位值：0x0

## SCR
- Name: Scratch Register
- Description: 暂存寄存器
- Size: 32 bits
- Offset: 0x1C
- Exists: Always

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_SCR_31to8 | R     | 保留位，读取为 0                                                      |
| 7:0    | SCR            | R/W   | 暂存寄存器。<br>这是一个 8 位读/写寄存器，供程序员用作暂存空间              |

注意：
- 这个寄存器没有特定的硬件功能
- 复位值：0x0

## LPDLL
- Name: Low Power Divisor Latch Low
- Description: 低功耗除数锁存器低位
- Size: 32 bits
- Offset: 0x20
- Exists: 当 UART_16550_COMPATIBLE = NO 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_LPDLL_31to8 | R   | 保留位，读取为 0                                                      |
| 7:0    | LPDLL          | R/W   | 低功耗除数锁存器的低 8 位。<br>用于在自动流控模式下设置波特率                |

注意：
- 仅在自动流控模式下使用
- 复位值：0x0

## LPDLH
- Name: Low Power Divisor Latch High
- Description: 低功耗除数锁存器高位
- Size: 32 bits
- Offset: 0x24
- Exists: 当 UART_16550_COMPATIBLE = NO 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_LPDLH_31to8 | R   | 保留位，读取为 0                                                      |
| 7:0    | LPDLH          | R/W   | 低功耗除数锁存器的高 8 位。<br>用于在自动流控模式下设置波特率                |

注意：
- 仅在自动流控模式下使用
- 复位值：0x0

## SRBRn
- Name: Shadow Receive Buffer Register n
- Description: 影子接收缓冲寄存器 n (n = 0 到 15)
- Size: 32 bits
- Offset: 0x30 + 4*n
- Exists: 当 SHADOW = YES 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_SRBR_31to8 | R    | 保留位，读取为 0                                                      |
| 7:0    | SRBR           | R     | 影子接收缓冲寄存器。<br>包含从串行接口接收的数据字符                        |

注意：
- 这些是只读寄存器
- 复位值：0x0

## STHRn
- Name: Shadow Transmit Holding Register n
- Description: 影子发送保持寄存器 n (n = 0 到 15)
- Size: 32 bits
- Offset: 0x30 + 4*n
- Exists: 当 SHADOW = YES 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_STHR_31to8 | R    | 保留位，读取为 0                                                      |
| 7:0    | STHR           | W     | 影子发送保持寄存器。<br>包含要通过串行接口发送的数据字符                    |

注意：
- 这些是只写寄存器
- 复位值：0x0

## FAR
- Name: FIFO Access Register
- Description: FIFO 访问寄存器
- Size: 32 bits
- Offset: 0xF0
- Exists: 当 FIFO_ACCESS = YES 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:1   | RSVD_FAR_31to1 | R     | 保留位，读取为 0                                                      |
| 0      | FAR            | R/W   | FIFO 访问模式使能。<br>0: 正常模式<br>1: FIFO 访问模式使能              |

注意：
- 复位值：0x0

## TFR
- Name: Transmit FIFO Read
- Description: 发送 FIFO 读取
- Size: 32 bits
- Offset: 0xF4
- Exists: 当 FIFO_ACCESS = YES 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:8   | RSVD_TFR_31to8 | R     | 保留位，读取为 0                                                      |
| 7:0    | TFR            | R     | 发送 FIFO 读。<br>在 FIFO 访问模式下从发送 FIFO 顶部读取数据             |

注意：
- 这是一个只读寄存器
- 复位值：0x0

## RFW
- Name: Receive FIFO Write
- Description: 接收 FIFO 写入
- Size: 32 bits
- Offset: 0xF8
- Exists: 当 FIFO_ACCESS = YES 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:10  | RSVD_RFW_31to10| R     | 保留位，读取为 0                                                      |
| 9      | RFWD           | W     | 接收 FIFO 写数据的帧错误状态                                           |
| 8      | RFPE           | W     | 接收 FIFO 写数据的奇偶校验错误状态                                      |
| 7:0    | RFWD           | W     | 接收 FIFO 写数据。<br>在 FIFO 访问模式下写入接收 FIFO                   |

注意：
- 这是一个只写寄存器
- 复位值：0x0

## USR：UART Status Register
- Name: UART Status Register
- Description: UART 状态寄存器
- Size: 32 bits
- Offset: 0x7C
- Exists: 当 UART_16550_COMPATIBLE = NO 时

| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:5   | RSVD_USR_31to5 | R     | 保留位，读取为 0                                                      |
| 4      | RFF            | R     | 接收 FIFO 满。<br>0: 接收 FIFO 未满<br>1: 接收 FIFO 满               |
| 3      | RFNE           | R     | 接收 FIFO 非空。<br>0: 接收 FIFO 空<br>1: 接收 FIFO 非空             |
| 2      | TFE            | R     | 发送 FIFO 空。<br>0: 发送 FIFO 非空<br>1: 发送 FIFO 空               |
| 1      | TFNF           | R     | 发送 FIFO 未满。<br>0: 发送 FIFO 满<br>1: 发送 FIFO 未满             |
| 0      | BUSY           | R     | UART 忙。<br>0: UART 空闲<br>1: UART 正在发送/接收数据                |

注意：
- 这是一个只读寄存器
- 复位值：0x6 (TFE 和 TFNF 位置 1)

## TFL：Transmit FIFO Level
- Name: Transmit FIFO Level
- Description: 发送 FIFO Level
- Size: 32 bits
- Offset: 0x80
- Exists: 当 FIFO_STAT = YES 时


| 位域   | 名称  | 访问  | 描述                                   |
| ---- | --- | --- | ------------------------------------ |
| 31:0 | TFL | R   | 发送 FIFO Level。<br>指示发送 FIFO 中当前的数据数量 |

注意：
- 这是一个只读寄存器
- 复位值：0x0

## RFL: Receive FIFO Level
- Name: Receive FIFO Level
- Description: 接收 FIFO Level
- Size: 32 bits
- Offset: 0x84
- Exists: 当 FIFO_STAT = YES 时

| 位域   | 名称  | 访问  | 描述                                   |
| ---- | --- | --- | ------------------------------------ |
| 31:0 | RFL | R   | 接收 FIFO Level。<br>指示接收 FIFO 中当前的数据数量 |

注意：
- 这是一个只读寄存器
- 复位值：0x0

## SRR
- Name: Software Reset Register
- Description: 软件复位寄存器
- Size: 32 bits
- Offset: 0x88
- Exists: 当 UART_16550_COMPATIBLE = NO 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:3   | RSVD_SRR_31to3 | R     | 保留位，读取为 0                                                      |
| 2      | XFR            | W     | XMIT FIFO 复位。<br>写 1 复位发送 FIFO                               |
| 1      | RFR            | W     | RCVR FIFO 复位。<br>写 1 复位接收 FIFO                               |
| 0      | UR             | W     | UART 复位。<br>写 1 复位所有 UART 寄存器                              |

注意：
- 这是一个只写寄存器
- 写入后自动清零
- 复位值：0x0

## SRTS
- Name: Shadow Request to Send
- Description: 影子请求发送
- Size: 32 bits
- Offset: 0x8C
- Exists: 当 UART_16550_COMPATIBLE = NO 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:1   | RSVD_SRTS_31to1| R     | 保留位，读取为 0                                                      |
| 0      | SRTS           | R/W   | 影子请求发送。<br>控制 rts_n 输出的状态                                |

注意：
- 复位值：0x0

## SBCR
- Name: Shadow Break Control Register
- Description: 影子中断控制寄存器
- Size: 32 bits
- Offset: 0x90
- Exists: 当 UART_16550_COMPATIBLE = NO 时

### 寄存器位定义
| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:1   | RSVD_SBCR_31to1| R     | 保留位，读取为 0                                                      |
| 0      | SBCR           | R/W   | 影子中断控制。<br>控制串行输出上的中断状态                               |

注意：
- 复位值：0x0

## DLF：小数分频寄存器
- Name: Divisor Latch Fraction
- Description: 除数锁存分数寄存器
- Size: 32 bits
- Offset: 0xC0
- Exists: 当 FRACTIONAL_BAUD = YES 时

| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:DLF_SIZE | RSVD_DLF_31toDLF_SIZE | R | 保留位，读取为 0                                            |
| DLF_SIZE-1:0 | DLF      | R/W   | 除数锁存分数值。<br>用于实现分数波特率。<br>实际分数值 = DLF/(2^DLF_SIZE)    |

注意：
- DLF_SIZE 是可配置参数，决定分数部分的精度
- 仅当 FRACTIONAL_BAUD = YES 时存在
- 复位值：0x0


1. 波特率计算公式：
   ```
   波特率 = (串行时钟频率) / (16 * (DLH:DLL + DLF/(2^DLF_SIZE)))
   ```

2. 配置步骤：
   - 设置 LCR.DLAB = 1
   - 写入 DLH、DLL 设置整数部分
   - 写入 DLF 设置分数部分
   - 清除 LCR.DLAB = 0

3. 示例 (DLF_SIZE = 4)：
   - DLF = 0x8 表示分数值为 8/16 = 0.5
   - DLF = 0x4 表示分数值为 4/16 = 0.25


## DMASA  ???? 干啥用的
- Name: DMA Software Acknowledge
- Description: DMA 软件确认寄存器
- Size: 32 bits
- Offset: 0x94
- Exists: 当 UART_16550_COMPATIBLE = NO 时


| 位域    | 名称            | 访问  | 描述                                                                |
|--------|----------------|-------|-------------------------------------------------------------------|
| 31:1   | RSVD_DMASA_31to1| R    | 保留位，读取为 0                                                     |
| 0      | DMASA          | R/W   | DMA 软件确认。<br>写 1 触发一个 DMA 确认信号。<br>用于在 DMA 传输完成后清除 DMA 请求。 |

注意：
- 仅当使用 DMA 传输时有效
- 写入后自动清零
- 复位值：0x0

使用说明：
1. DMA 传输完成后，需要写 1 到此寄存器以清除 DMA 请求
2. 通常在以下情况使用：
   - DMA 传输完成后
   - 需要手动终止 DMA 传输时
   - 重新开始新的 DMA 传输前
3. 写入 1 会产生一个脉冲信号，用于确认 DMA 操作完成


## HTX
- Name: Halt TX
- Description: 暂停发送寄存器
- Size: 32 bits
- Offset: 0xA4
- Exists: 当 UART_16550_COMPATIBLE = NO 时

| 位域   | 名称             | 访问  | 描述                                    |
| ---- | -------------- | --- | ------------------------------------- |
| 31:1 | RSVD_HTX_31to1 | R   | 保留位，读取为 0                             |
| 0    | HTX            | R/W | 暂停发送。<br>0: 正常发送<br>1: 在当前字符发送完成后暂停发送 |

注意：
- 复位值：0x0
- 写 1 会在当前字符发送完成后暂停发送
- 写 0 恢复发送操作

### 使用说明
1. 暂停发送：
   - 写 1 到 `HTX[0]`
   - 当前字符发送完成后，发送操作会暂停
   - TX FIFO 中的数据会保持不变

2. 恢复发送：
   - 写 0 到 `HTX[0]`
   - 发送操作立即恢复
   - TX FIFO 中的数据会继续发送

3. 常见用途：
   - 流控制
   - 发送暂停
   - 同步操作




# 功能特性：

## 测试用例

### 测试 dma 传输功能
- 打开 `dw_uart.c` 中的 `ENABLE_UART_DMA_TEST` 宏，然后发送接收即可

### 测试偶校验
- 没有奇偶校验的代码

### 测试发送中断
- 只有接收中断

### 测试发送硬件 FIFO 大小
- 使用 `uarttest tx_fifo_size` 命令测试
- 能够得到 `tx fifo` 大小

### 测试多种波特率
- `uarttest baudrate [baudrate]`
- 把 `minicom` 配成对应的波特率，接线接到要测试的 uart 端口，来查看数据是否正确

### 测试奇校验
- 没有奇偶校验的代码

### 测试小数波特率
- 打开 `dw_uart.c` 中的 `DW_UART_FRACTIONAL_BAUD_DIV UART_DLF_SIZE` 跑上面的波特率测试

### 测试接收终端
- 打开中断，串口能够正常接收数据

### 测试接收硬件 FIFO 大小
- `uarttest rx_fifio_size`，怎么往里面放 rx fifo 放数据？

### 测试硬件流控 CTS
- 按照步骤描述

### 测试硬件流控 RTS
- 按照步骤描述

### 测试波特率检测功能
- brc

### 测试串口长时间收发
- 怎么测试？

### 测试波特率和实际波特率偏差
- `uart_brc_test`


# 驱动分析

## gxloader
- 非中断
	- init: 设置波特率、81N、FIFO Enable (Mode1)、
	- uart_getc:
		- 循环查询 `LSR. DR = 1` 表示数据准备好了
		- 从 `RBR` 寄存器读一个字符
	- uart_putc:
		- 循环查询 `LSR.TEMT` 等待 `tx fifo empty`
		- 把字符往 `THR` 寄存器写
	- 设置波特率：让波特率尽可能准确
		- 设置 LCR 寄存器的 DLAB 位
		- 循环查询 `USR.BUSY`
		- 手册描述时钟分频计算方法：`clkdiv = uart_clock / (16*baudrate)`
		- 驱动中的时钟分频计算方法：`clkdiv = (uart_clock + (8*baudrate)) / (16*baudrate)
		- 小数波特率计算方法：`主频/（16*baudrate） = 整数 + 小数`，`小数*2^DLF_SIZE = dlf`，将这个值写到 `DLF` 寄存器
			- 驱动计算方法：`先算出小数部分，再 * 2^DLF_SIZE，然后将算出来的值除以波特率，进行四舍五入，得到 dlf，写到 DLF 寄存器`  
		- 把计算出来的 `clkdiv` 高 `8` 位写到 `DLH`，低 `8` 位写到 `DLL`，并且小数波特率写到 `DLF` 寄存器
	- 获取 fifo 深度
		- 从 `CPR` 寄存器的第 16 位获取配置的 fifo 深度
	- 获取触发 `tx fifo empty` 或 ` rx fifo 数据可用 ` 中断
		- rx：从影子寄存器 `SRT` 中读到配置的 rx 触发等级
		- tx：从影子寄存器 `STET` 中读到配置的 tx 触发等级
	- uart_tstc
		- 读 `LSR` 寄存器，如果有数据可读返回 1，无数据可读返回 0
	- uart_halt_tx
		- 配置 `HTX` 寄存器为 1 则停止发送；配置为 0 则继续发送
	- uart_get_tx_fifo_size
		- 读 `TFL` 寄存器获取当前 `tx fifo` 中有多少个数据
	- uart_get_rx_fifo_size
		- 读 `RFL` 寄存器获取当前 `rx fifo` 中有多少个数据
	- uart_enable_auto_flow
		- 读 `MCR` 寄存器
		- 修改 `MCR` 寄存器中的 `AFCE、RTS` 位来启用 `tx、rx` 的自动流控
		- 写回寄存器
		- 配置 `FCR` 寄存器为 `0xC7`
		- 备注：
			- `RTS` 信号用于发送请求，为输出信号，表示准备好接收数据了，低电平有效
			- `CTS` 信号用于接收请求，为输入信号，表示可以发送数据了，低电平有效
			- 使能 `RTS`后告诉对方设备可以发数据了
			- 对方设备开始发数据
			- 发数据过程中一直检测自己的 fifo 情况，如果不能接收数据了就会拉高 `RTS` 引脚，对方的 `CTS` 为输入信号，检测到拉高之后就会暂停传输数据。
			- 等自己的 fifo 有空闲了，自动拉低 `RTS` 引脚继续传输
	- uart_start_break
		- 读 `LCR` 寄存器
		- 修改，配置 `BC` 位，用于停止 `transmit`
		- 写回 `LCR` 寄存器
	- uart_end_break
		- 读 `LCR` 寄存器
		- 修改，清掉 `BC` 位，用于恢复 `transmit`
		- 写回 `LCR` 寄存器
- 中断
	- init：
		- alloc 一个 kfifo
		- 写 `IER` 寄存器为 1 使能接收中断
		- 注册中断服务函数
	- irq：
		- 读 `LSR` 寄存器，查询是否有数据
		- 有数据则从 `RBR` 寄存器读一个字节数据，然后把数据放到 kfifo
	- uart_flush_in
		- 关中断
		- 清空 kfifo
		- 开中断
	- getc
		- 判断 kfifo 是否有数据
		- 有数据从 kfifo 取一个字节；没有数据返回 0
- dma
	- prepare
		- **配置 `DMASA` 寄存器为 1 ???????? 干什么用的？先清一下？**
	- get_dma_burst_size
		- 获取触发等级
		- 根据触发等级配置对应的 burst_size
	- uart_get_per
		- 根据传入的 port 获取握手信号
	- uart_raw_putc
		- 配置 dma
		- 使用同步 dma
		- 启动 dma，传输长度是 1
	- uart_dma_getc
		- 从 RBR 寄存器读数据到 sram
		- 配置 dma 为异步 dma
		- 启动 dma，传输长度是 1
- brc
	- 上位机连续发送 0xef，小端先发，加上 Start、Stop 位的波形如下： ![[Pasted image 20250212110702.png]]
	- 用于测量串口传输的波特率
	- 等待 brc 检测完成
	- 检测完成计算 uart 传输 5bit 数据的所耗费的周期时间
	- `brc_val1`：第二个下降沿到第三个下降沿的时间，一直发 0xef 就刚好是 5bit 数据的传输时间
	- `brc_val2` ：第二个下降沿到第四个下降沿的时间，一直发 0xef 就刚好是 10bit 的传输时间
	- width = 5bit 传输的周期数
	- 如果 `width <79` 则认为不可用，如果 ` width==79`，就认为耗时 80，否则的话就是正常的值
	- 波特率计算方法：
		- 一个时钟周期：`1/F`
		- width 个周期耗时：`width * 1/F`
		- 但是 width 的周期是 5bit 才占这么久，所以 `width/5*F` 表示 1bit 耗时的时间
		- `baud  = 1/周期`
			- 因为 baud 表示的是每秒传输多少 b 的数据，就是 `f --> = 1/周期`
		- 最后计算 uart 的工作频率为：`Freq = (baud * width)/5` 
		- 因此可以通过上位机一直发 0xef 来得到 uart 的工作频率

## ecos


## linux


### 概念

#### 终端、tty 设备、控制台
![[Pasted image 20250213095155.png]]

#### tty 框架
对上，向应用程序提供使用终端的统一接口；对下，提供编写终端驱动程序（如serial driver）的统一框架。



### 驱动

- 如何支持多个串口
	- probe 的时候每次匹配到设备树信息只有就注册一个串口，用 malloc 的方式创建串口相关的数据接口，然后注册到系统中
	- 每来一个就 malloc 一个，这样可以同时支持多个串口
- probe
	- 从设备树获取寄存器信息 regs
	- 从设备数获取中断号 irq


https://zhuanlan.zhihu.com/p/666660181
https://www.cnblogs.com/fuzidage/p/18203864
https://developer.aliyun.com/article/1421624


#### 8250


##### 8250_core . c


- serial8250_init
	- 


##### 8250_port. c




##### 8250_dma. c




##### 8250_dw. c






