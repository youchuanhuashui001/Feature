---
tags:
  - Linux_Driver/Kernel_Fundamentals
aliases:
  - 自旋锁
  - spinlock
---
# Spinlock (自旋锁)

## 1. 核心概念
`spinlock` (自旋锁) 是 Linux 内核中最基本、最常用的一种同步原语，用于在多处理器环境（SMP）和抢占式内核中保护共享数据结构，防止并发访问导致的竞争状态（Race Condition）。

**核心思想：忙等待 (Busy-Waiting)**

自旋锁的核心思想是“忙等待”。当一个执行单元（例如一个 CPU 核心上运行的线程）试图获取一个已经被其他执行单元持有的自旋锁时，它不会像互斥锁 (mutex) 那样进入睡眠（阻塞），让出 CPU。相反，它会进入一个紧凑的循环（“自旋”），不断地检查锁是否已经被释放。

*   **优点**: 因为避免了进程上下文切换的开销（这通常很耗时），所以对于**锁的持有时间极短**的临界区，自旋锁的效率非常高。
*   **缺点**: 如果锁被持有的时间较长，忙等待会持续消耗 CPU 时间，造成浪费。因此，自旋锁保护的临界区代码必须尽可能快地执行完毕。 <font color="#ff0000">CPU 会一直自旋等待，100%占用当前核心。</font>

## 2. 使用场景

**主要功能与使用场景**
自旋锁的主要功能是提供互斥访问。它的最关键使用场景是：

1.  **中断上下文**: 中断服务程序 (ISR) 中绝对不能睡眠。因此，当共享数据可能被中断处理函数访问时，必须使用自旋锁而不是互斥锁来保护。这是自旋锁在驱动程序中最常见的用途。
2.  **多处理器共享数据**: 在多核系统中，当不同 CPU 上的代码需要访问同一片数据时，自旋锁可以确保同一时刻只有一个 CPU 能访问该数据。

**关键规则**

使用自旋锁必须遵守严格的规则：
*   **禁止睡眠**: 持有自旋锁期间，代码绝对不能调用任何可能导致睡眠的函数（例如 `kmalloc(GFP_KERNEL)`、`copy_from_user()`、`msleep()` 或者获取一个互斥锁）。否则可能导致系统死锁。
*   **快速执行**: 临界区代码必须简短、快速，以避免其他 CPU 核心长时间忙等待。
*   **不能递归**: 同一个线程不能两次获取同一个自旋锁，否则会造成死锁（自己等待自己释放锁）。


## 3. 核心 API 
自旋锁的 API 主要处理加锁、解锁，以及与中断和抢占的交互。

*   **定义与初始化**:
    ```c
    spinlock_t my_lock;             // 定义一个自旋锁
    spin_lock_init(&my_lock);       // 初始化自旋锁
    ```

*   **基本加锁/解锁**:
    *   `spin_lock(&my_lock);`: 获取锁。在获取锁的同时会禁用当前 CPU 的内核抢占，防止持有锁时被其他任务抢占。
    *   `spin_unlock(&my_lock);`: 释放锁，并重新启用内核抢占。

*   **与中断交互 (最常用)**:
    *   `spin_lock_irqsave(&my_lock, unsigned long flags);`: 这是最安全、最常用的变体。它会：
        1.  保存当前 CPU 的中断状态到 `flags` 变量中。
        2.  **禁用本地 CPU 的中断**。
        3.  获取自旋锁。
    *   `spin_unlock_irqrestore(&my_lock, unsigned long flags);`:
        1.  释放自旋锁。
        2.  恢复之前保存的中断状态到 `flags`。

    **为什么需要 `_irqsave`?**
    这是为了防止在“进程上下文”和“中断上下文”之间共享数据时发生死锁。设想一个场景：
    1.  你的驱动在进程上下文（例如响应 `write` 系统调用）获取了自旋锁 `my_lock`。
    2.  此时，一个硬件中断在本 CPU 上发生。
    3.  内核暂停当前进程，转而执行该中断的 ISR。
    4.  ISR 也想获取同一个自旋锁 `my_lock`。
    5.  由于锁已被进程上下文持有，ISR 开始自旋等待。但持有锁的进程代码已经被中断，永远无法继续执行去释放锁。
    6.  **死锁发生**：ISR 在死等，整个 CPU 被卡住。
    `spin_lock_irqsave` 通过在获取锁之前禁用本地中断，彻底杜绝了这种情况的发生。


## 4. 个人理解
- 首先需要初始化`spin_lock_init(&lock)`
- 如果需要上锁，则使用 `spin_lock(&lock)`
- 如果需要解锁，则使用`spin_unlock(&lock)`
- 第一个上锁的拥有者可以成功锁定，锁定后第二个核执行时就会自旋等待，cpu 一直占用在这里查询，直到锁的拥有者解锁后才可以拥有锁。
- 需要用在很短的时间内就能干完的场景，或者 irq 上下文