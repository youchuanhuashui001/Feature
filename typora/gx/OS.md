# OS

1. 提供管理各种计算机硬件+为应用程序提供接口

2. 发展及分类

   1. 单道：让所有的指令顺序执行
   2. 多道：有程序等待时，让cpu执行不需等待的程序，让cpu尽可能忙起来
   3. 分时：时间片轮转
   4. 实时：实时响应，但用户交互性差一点

3. cpu执行两种程序

   1. 操作系统内核程序：与硬件关联较紧密的模块(clk、interrupt、原语、系统控制的数据结构及处理) --> 内核态
   2. 用户自编程序或系统外层的应用程序 --> 用户态

4. 用户态和内核态切换：中断和异常

   1. 中断：来自cpu执行指令以外的事件的发生，如设备发出的io作业结束中断，固定的时间片中断等
   2. 异常：内中断，源自cpu执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出等

5. 系统调用：用户在程序中调用操作系统所提供的一些子功能

   1. 设备管理：完成设备的请求或释放，以及设备启动等功能
   2. 文件管理：完成文件的读写、创建及删除等功能
   3. 进程控制：完成进程的创建、撤销、阻塞及唤醒等功能
   4. 进程通信：完成进程之间的消息传递或信号传递等功能
   5. 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及起始地址等功能

   用户通过操作系统运行上层程序，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入内核态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务

6. 操作系统的体系结构：大内核和微内核

   1. 大内核：尽可能支持完善
   2. 微内核：经常需要切换用户态和内核态，尽可能裁剪的小
   3. 库操作系统：将系统服务作为运行库连接到用户程序

7. 进程

   1. 为了保证参与并发执行的程序(含数据)能独立的运行，必须配置一个专门的数据结构(PCB:Process Control Block)，用来描述进程的基本情况和运行状态，进而控制和管理进程

   2. 进程的状态：

      1. 运行：正在运行

      2. 就绪：准备运行

      3. 阻塞：等待状态

      4. 创建：正在被创建，还未就绪

      5. 结束：正在从系统中消失

         ![image-20220301151034543](/home/tanxzh/txz/my/note/image/image-20220301151034543.png)

   3. 进程的控制：

      1. 进程的创建：

         1. 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB
         2. 为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间(在PCB中体现)
         3. 初始化PCB，主要包括初始化标识信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等
         4. 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度

      2. 进程的终止：正常结束(任务以及完成和准备退出运行)或异常结束(发生异常事件)

         1. 根据被终止进程的标识符，检索PCB，从中读出该进程的状态
         2. 若被终止进程处于执行状态，立即停止该进程的执行，将处理机资源分配给其他进程
         3. 若该进程还有子进程，则应将其所有子进程终止
         4. 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统
         5. 将该PCB从所在队列(链表)中删除

      3. 进程的阻塞和唤醒：等待某种操作造成阻塞，得到操作完成则唤醒

         1. 阻塞：
            1. 找到将要阻塞进程的标识号对应的PCB
            2. 若该进程为运行状态，则保护其现场，将其状态转换为阻塞状态，停止运行
            3. 把该PCB插入到相应时间的等待队列中
         2. 唤醒：
            1. 在该事件的等待队列中找到相应进程的PCB
            2. 将其从等待队列中移出，并置其状态位就绪状态
            3. 把该PCB插入就绪队列中，等待调度程序调度
         3. 进程切换：处理机从一个进程的运行转到另一个进程上运行
            1. 保存处理机上下文，包括程序计数器和其他寄存器
            2. 更新PCB信息
            3. 把进程的PCB移入相应的队列，如等待、就绪 等
            4. 选择另一个进程执行，并更新其PCB
            5. 更新内存管理的数据结构
            6. 恢复处理机上下文

      4. 进程的组织：进程是操作系统的资源分配和独立运行的基本单位。一般由控制块、程序段和数据段组成。

         1. 进程控制块
            1. 进程创建时，os就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取，在进程结束时删除。
               ![image-20220301152635178](/home/tanxzh/txz/my/note/image/image-20220301152635178.png)
         2. 程序段：能被进程调度程序调度到cpu执行的程序代码段。程序可以被多个进程共享，就是说多个进程可以运行同一个程序
         3. 数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

      5. 进程通信：

         1. 低级通信：PV
         2. 高级通信：
            1. 共享存储：在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读写操作实现进程之间的信息互换。通常使用同步、互斥
            2. 消息传递：进程间的数据交换是以格式化的信息为单位进行传输的
            3. 管道：连接一个读进程和一个写进程以实现通信一个共享文件

      6. 线程：

         1. 引入进程的目的：是为了使多道程序并发执行，以提高资源利用率和系统吞吐量
         2. 引入线程的目的：为了减小程序在并发执行是所付出的时空开销，提高操作系统的并发性能
         3. 线程不拥有系统资源，可以与同属一个进程的其他线程共享进程所拥有的全部资源

      7. 处理机的调度：

         1. 处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发的执行。
            ![image-20220301154355220](/home/tanxzh/txz/my/note/image/image-20220301154355220.png)

      8. 进程同步：

         1. 临界区：在每个进程中，访问临界资源的那段代码称为临界区
         2. 对于临界区资源主要有同步(协作)和互斥(竞争)

      9. 管程：

         1. 系统中各种硬件资源和软件资源，均可用数据结构抽象的描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据智商的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。
         2. 管程的组成：
            1. 局部于管程的共享结构数据说明
            2. 对该数据结构进行操作的一组进程
            3. 对局部于管程的共享数据设置初始值的语句
         3. 管程的基本特性：
            1. 局部于管程的数据只能被局部于管程内的过程所访问
            2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
         4. 每次仅允许一个进程在管程内执行某个内部过程
            由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无须程序员关注，而且保证正确

      10. 内存管理：

          1. 创建进程首先要将程序和数据装入内存，包括编译、链接、装入![image-20220301155959173](/home/tanxzh/txz/my/note/image/image-20220301155959173.png)
          2. 静态链接：在程序运行之前，先将各目标模块及他们所需的库函数链接成一个完整的可执行程序，以后不再拆开
          3. 装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式
          4. 运行时动态链接：对某些目标模块的链接，实在程序执行中需要该目标模块时，才对它进行的链接
          5. 内存的装入模块在装入内存时：
             1. 绝对装入：编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。
             2. 可重定位装入：根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中的数据和指令的修改过程称为重定位。
             3. 动态重定位：动态运行时装入，程序在内存中如果发生移动，就需要采用动态的装入方式。
          6. 逻辑地址空间和物理地址空间
             1. 编译后，每个目标模块都是以0号空间开始编制，称为逻辑地址。当连接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号地址开始编译的逻辑地址空间。
             2. 物理地址：内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。
          7. 内存覆盖和内存交换
             1. 内存覆盖：由于程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。
             2. 内存交换：把处于等待的程序从内存移到辅存，把准备好竞争cup运行的程序从辅存移到内存
             3. 交换是在不同进程之间进行，而覆盖是在同一个进程中进行。

      11. IO管理

          1. io设备及其分类

             1. 人机交互类设备、存储设备、网络通信设备
             2. 低速设备、中速设备、高速设备
             3. 块设备、字符设备

          2. io控制方式

             1. 程序直接控制方式：计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在IO控制器的数据寄存器内。
             2. 中断驱动方式：允许io设备主动打断cpu的运行并请求服务，从而解放cpu，使得其向io控制器发送读命令后可以继续做其他有用的工作。
             3. DMA方式：在io设备和内存之间开辟直接的数据交换桐庐，所传送的数据从设备中直接送入内存中。
             4. 通道控制方式：专门负责输入/输出的处理机。
                1. io通道与一般处理机的区别：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。
                2. io通道与DMA方式的区别：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。

          3. io子系统的层次结构
             ![image-20220301185436935](/home/tanxzh/txz/my/note/image/image-20220301185436935.png)

             1. 用户层IO软件：实现与用户交互的接口，用户可以直接调用在用户层提供的，与io操作有关的库函数，对设备进行操作。用户层软件必须通过一组系统调用来获取操作系统服务。

             2. 设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护以及设备分配和释放等，同时为设备管理和数据传送提供必要的存储空间。

                为了实现设备独立性，必须在驱动程序之上设置一层设备独立性软件，向用户层提供统一接口，无论何种设备，他们向用户所提供的接口应该是相同的(例如：对各种设备的读写操作，在应用程序中都统一使用read、write命令等)

             3. 设备驱动程序：与硬件直接相关，负责具体实现系统对设备所发出的操作指令，驱动io设备工作的驱动程序。

             4. 中断处理程序：用于保存被中断进程的cpu环境，转入相应的终端处理程序进行处理，处理完并恢复被终端进程的现场后，返回被中断过程。

             5. 硬件设备

          4. io子系统

             1. 由于io设备种类繁多，功能和传输速率差异较大，需要多种方法来进行设备控制。这些方法组成了操作系统内核的io子系统。io子系统提供的服务主要有io调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等。
             2. io调度就是确定一个好的顺序来执行这些io请求。