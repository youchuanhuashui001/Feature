# A7 Nos

## IRQ

记录 imx6ull 开发板的 gpio 中断和 canopus 的 spi 中断详细过程以及差异。

- spi 中断

  - 首先是通过 cp15 配置全局中断使能，注册 spi 中断这些东西

    - 中断掩码寄存器(IMR)：用于 mask / enable 对应的中断，因为一般外设有多种中断情况，将这些中断信号都混合成一个统一的中断

    - 中断状态寄存器(ISR)：用于获取中断状态

    - 中断状态清除寄存器(ICR)：用于清除中断状态，read 清除中断

- gpio 中断

  - 中断配置寄存器(ICR)：用于配置 gpio 中断的触发类型
  - 中断掩码寄存器(IMR)：用于 mask(屏蔽) / enable 对应的中断
  - 中断状态寄存器(ISR)
  - 中断边沿选择寄存器：用于选择边沿触发

  

- 驱动处理流程：

  - GIC 初始化

    - 通过内嵌汇编操作 cp15 寄存器获取 gic 基地址
    - 读 `GICD_TYPER` 寄存器获取 max 中断数
    - 配置 `GICD_ICENABLER` 寄存器关掉所有的 中断
    - 配置 `GICC_PMR` 设置优先级等级，高于这个级别的才可以触发 cpu 中断
    - 配置 `GICC_BPR` 设置抢占优先级，允许各个优先级进行抢占
    - 配置 `GICD_CTLR`  使能 group0 允许从分发器路由到 cpu 接口端
    - 配置 `GICC_CTLR` 使能 group0 允许发生中断

  - 汇编部分：`start.s` 配置好中断向量基址、中断向量表、中断栈，然后跳转到中断处理函数

    > `stmdb sp!, {r0-r12, lr}`：把 r0-r12，lr_irq - 4 保存到栈上
    >
    > `ldmia sp!, {r0-r12, pc}^`：把保存在栈上的值恢复到 r0-r12，把之前保存的 `lr_irq - 4` 恢复到 pc；同时，把 spsr 中保存的被中断状态的 cpsr，恢复到 cpsr(^ 就是干这个活的)

  - 中断处理函数：

    - 通过汇编操作 cp15 寄存器获取 gic 基地址
    - 通过读取 `GICC_IAR` 寄存器获取发生中断的  ID
    - 执行对应中断 ID 的中断处理函数 --> 具体的中断服务函数 --> 在此之前要先注册
    - 配置`GICC_EOIR` 寄存器以表示中断处理完成

  - gpio 中断注册和处理函数

    - 注册：key_irq_init 接口中会配置 `IMR、ISR、EDGE_SEL` 寄存器，然后注册 irq handler
    - 处理：获取具体的中断状态，清除中断状态(写 1 清零)

  - 使能具体的中断：`这里一般来说是默认使能所有中断号的`

    - 配置 gic 的 `GICD_ISENABLERn` 寄存器根据要使能的中断号使能具体的中断



