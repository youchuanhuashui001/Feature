#include "stdio.h"
#include "string.h"
#include "irr.h"
#include "interrupt.h"
#include "gx_irr_v2.h"
#include "gx_api.h"
#include "gxhwlib_registers.h"
#include "version_autogenerated.h"

#if 0
#define IRR_DBG(...)                printf( __VA_ARGS__)
#else
#define IRR_DBG(...)
#endif

//#define FIFO_TEST

#define IRR_INTR_TIMEOUT_EN      (1 << 4)
#define IRR_INTR_DATA_RECEIVE_EN (1 << 3)
#define IRR_INTR_FIFO_EN         (1 << 2)
#define IRR_INTR_OVERFLOW_EN     (1 << 1)
#define IRR_INTR_REPEAT_EN       (1 << 0)

struct irr_code_info_t {
	uint32_t code;
	uint32_t is_simcode;
};

#define IRR_KFIFO_SIZE (sizeof(struct irr_code_info_t))

enum
{
    ISR_HANDLED  = 1,               /*  Interrupt was handled             */
    ISR_CALL_DSR = 2                /*  Schedule DSR                      */
};

static volatile unsigned int g_irr_simple_ignore_num = 4;

// Functions in this module
int irr_read(void *buffer, uint32_t *len);
int irr_ioctl(uint32_t key,void *buf);
unsigned char  irr_init(void);
int irr_close(void);

static gx_irr_extra irr_extra = {
    .irr_isrpri = 10,                 //int pri
    .irr_mode = O_NONBLOCK,           //mode
};

static int irr_parse_default(gx_irr_extra*  extra)
{
    return 0;
}

static int irr_parse_nec(gx_irr_extra*  extra)
{
	uint32_t i, sig_time, mark_time;
	uint32_t num = extra->pulse_num;

	mark_time = (extra->pulse_val[0] & 0xFFFF);

	if (((num > IRR_MAX_SIMCODE_PULSE_NUM) &&
			(num < IRR_MAX_FULLCODE_PULSE_NUM)) ||
		(num > IRR_MAX_FULLCODE_PULSE_NUM)||(num == 0)) {
		IRR_DBG("<warn>Receive interfere code.\n");
		return -1;
	}

	if ((mark_time < (7*IRR_PROTCOL_TIME))||(mark_time > (20*IRR_PROTCOL_TIME))) {
		IRR_DBG("<warn>Receive interfere code.\n");
		return -1;
	}

	/* deal with simcode */
	if (num <= IRR_MAX_SIMCODE_PULSE_NUM) {
		extra->counter_simple++;
		IRR_DBG("counter_simple:%d\n", extra->counter_simple);

		if (extra->counter_simple <= g_irr_simple_ignore_num) {
			return -1;
		} else {
			extra->is_simcode = 1;
			return 0;
		}
	} else {
		extra->counter_simple = 0;
	}

	/* decode */
	extra->key_code = 0;
	for (i = 1; i < IRR_MAX_FULLCODE_PULSE_NUM; i++) {
		mark_time = (extra->pulse_val[i] & 0xFFFF);
		sig_time  = (extra->pulse_val[i] >> 16);

		IRR_DBG("line(%d) mark_time[%d]:0x%x sig_time[%d]:0x%x\n",
			__LINE__, i, mark_time, i, sig_time);
		extra->key_code <<= 1;

		if((sig_time) < (IRR_AVERAGE_PULSE_WIDTH)) {
			extra->key_code |= 1;
		}
	}

	return 0;
}

static int irr_parse_philips(gx_irr_extra*  extra)
{
	uint32_t i;
	uint32_t sig_time;
	uint32_t mark_time;
	uint32_t low_time;
	uint32_t index = 0;
	uint32_t num   = extra->pulse_num;
	uint32_t key_bit   = 0;
	uint32_t key_value = 0;
	static volatile unsigned int g_irr_philip_temp  = 0;

	if ((num < IRR_RC5_MIN_PULSE_NUM) || (num > IRR_RC5_MAX_PULSE_NUM)){
	IRR_DBG("<warn>Receive interfere code.\n");
	return -1;
	}

	/* decode */
	extra->key_code = 0;
	index++; 		//first, we assume bit 0 = 0 for inverse
	for (i = 0; i < num; i++) { 

		sig_time  = (extra->pulse_val[i] >> 16);
		mark_time = (extra->pulse_val[i] & 0xFFFF);
		low_time  = sig_time - mark_time;

		IRR_DBG("%s() line(%d) mark_time[%d]:0x%x sig_time[%d]:0x%x\n", 
				__func__, __LINE__, i, mark_time, i, sig_time);

		if ((2 * mark_time) > (IRR_RC5_PROTCOL_TIME * 3)){
	
			key_bit |= (1 << index++);
			key_bit |= (1 << index++);
		}
		else{
			key_bit |= (1 << index++);
		}

		if ((2 * low_time) > (IRR_RC5_PROTCOL_TIME * 3)) {
		
			index++;
			index++;
		}
		else{
			index++;
		}
	}
	switch(index){
	
		case 25: //110
			key_bit |= (1 << index++);
			key_bit |= (1 << index++);
			index++;

			break;
		case 26: //10
			key_bit |= (1 << index++);
			index++;

			break;
		case 27: //1
			key_bit |= (1 << index++);

			break;
		default: //index == 27,0-27 28bit

			break;
	}

	/*Add 01/10 judgment in order to discard error keycode.*/
	for(i = 0; i < 28; i += 2){
		key_value <<= 1;
		if(0x0 == (uint8_t)((key_bit >> i) & 0x01)
		 && 0x1 == (uint8_t)((key_bit >> (i+1)) & 0x01))
		{
			key_value |= 1;
		}else if(0x01 == (uint8_t)((key_bit >> i) & 0x01)
        		&& 0x00 == (uint8_t)((key_bit >> (i+1)) & 0x01))
		{
			continue;
		}else
		{
			IRR_DBG("%s() line(%d) <warn>Receive interfere code.\n", __func__, __LINE__);
			return -1;
		}
	}

	/* deal with simcode */
	if((g_irr_philip_temp ^ key_value) & 0x800)
	{
		IRR_DBG("############%s() line(%d)################\n",
				__func__, __LINE__);
		extra->key_code   = key_value;
		g_irr_philip_temp = key_value;		
		extra->counter_simple = 0;   
	}else
	{
		extra->counter_simple++;    
		if(extra->counter_simple <= g_irr_simple_ignore_num){
			return -1;
		}else
		{
			extra->is_simcode = 1;
			extra->key_code   = key_value;
		}
	}

	/*Start bit must be 1*/
	if((extra->key_code & 0x2000) == 0) {
		IRR_DBG("%s() line(%d) <warn>Receive interfere code.\n", __func__, __LINE__);
		extra->is_simcode = 0;
		return -1;
	}

	extra->key_code &= 0x7ff; //get last 11 bits

	/*Rc5 F bit is used to extend data bits.If Rc5 F bit equal 0, the MSB of datacode is be 
	ignored in transmission, and the value of the datacode's MSB is 1, a total of 7bits.*/
	/*if((extra->key_code & 0x1000) == 0)
	{
		extra->key_code = ((extra->key_code & (0x1f<<6)) << 1) | (extra->key_code & 0x3f) | (1<<6);
	}*/
	
	return 0;
}

static int irr_parse_dvb_40bit(gx_irr_extra*  extra)
{
    uint32_t mark_time;
    uint32_t sig_time;
    uint32_t index;
    uint32_t key_code = 0;

    //32 bit key code
    key_code = 0;
    for (index = 16; index >8; index--)
    {
        mark_time = (extra->pulse_val[index] & 0xFFFF);
        sig_time  = (extra->pulse_val[index] >> 16);

        key_code <<= 1;
        if(sig_time > (IRR_AVERAGE_PULSE_WIDTH_STB40))
        {
            key_code |= 1;
        }
    }

    for (index = 24; index >16; index--)
    {
        mark_time = (extra->pulse_val[index] & 0xFFFF);
        sig_time  = (extra->pulse_val[index] >> 16);

        key_code <<= 1;
        if(sig_time > (IRR_AVERAGE_PULSE_WIDTH_STB40))
        {
            key_code |= 1;
        }
    }

    for (index = 33; index >25; index--)
    {
        mark_time = (extra->pulse_val[index] & 0xFFFF);
        sig_time  = (extra->pulse_val[index] >> 16);

        key_code <<= 1;
        if(sig_time > (IRR_AVERAGE_PULSE_WIDTH_STB40))
        {
            key_code |= 1;
        }
    }

    for (index = 41; index >33; index--)
    {
        mark_time = (extra->pulse_val[index] & 0xFFFF);
        sig_time  = (extra->pulse_val[index] >> 16);

        key_code <<= 1;
        if(sig_time > (IRR_AVERAGE_PULSE_WIDTH_STB40))
        {
            key_code |= 1;
        }
    }

    extra->key_code = key_code;
    return 0;
}

static int irr_parse_bescon(gx_irr_extra*  extra)
{
	uint32_t mark_time;
	uint32_t sig_time;
	uint32_t index;
	uint32_t key_code = 0;

	uint64_t bit_str;
	uint32_t sig_sub_mark;
	uint32_t pulse_index;
	static volatile unsigned int g_irr_bescon_temp  = 0;

	//D16-D14 :3位引导码
	//D13    :奇偶校验位，用来判断是否是简码，如取反则为全码，反之为简码
	//D12-D8 :5位系统码，恒为0
	//D7 -D0 :8位键码
	key_code = 0;
	bit_str = 0;
	pulse_index = 0;
	index = 0;

	//不处理第1个引导码
	for(pulse_index = 1; pulse_index < extra->pulse_num; pulse_index++)
	{
		mark_time = (extra->pulse_val[pulse_index] & 0xFFFF);
		sig_time = (extra->pulse_val[pulse_index] >> 16);

		sig_sub_mark = sig_time - mark_time;

		if(2*mark_time > 3*IRR_PROTCOL_TIME_BESCON)
		{
			bit_str |= (1 << index);
			index++;
			bit_str |= (1 << index);
			index++;
		}
		else
		{
			bit_str |= (1 << index);
			index++;
		}

		if(2*sig_sub_mark > 3*IRR_PROTCOL_TIME_BESCON)
		{
			index += 2;
		}
		else
		{
			index++;
		}
	}

	//因GX芯片截取红外脉冲的特征，可能会没记录到最后的一些位的数据
	//需要进行修正
	if((2*IRR_MAX_PULSE_NUM_BESCON) - index == 1)
	{
		bit_str |= (1 << (index));
	}
	else if((2*IRR_MAX_PULSE_NUM_BESCON) - index == 2)
	{
		bit_str |= (1 << (index));
	}
	else if((2*IRR_MAX_PULSE_NUM_BESCON) - index == 3)
	{
		bit_str |= (1 << (index));
		bit_str |= (1 << (index + 1));
	}

	//计算key_code
	for(index = 0;index < (2*IRR_MAX_PULSE_NUM_BESCON);index += 2)
	{
		key_code <<= 1;
		if(0x00 == (uint8_t)((bit_str >> index) & 0x01)
				&&0x01 == (uint8_t)((bit_str >> (index+1)) & 0x01))
		{
			key_code |= 1;
		}
		else if(0x01 == (uint8_t)((bit_str >> index) & 0x01)
				&&0x00 == (uint8_t)((bit_str >> (index+1)) & 0x01))
		{
			continue;
		}
		else
		{
			key_code = 0xFFFFFFFF;
			break;
		}
	}

	/* deal with simcode */
	if((g_irr_bescon_temp ^ key_code) & (1<<13)) {

		extra->key_code   = key_code;
		g_irr_bescon_temp = key_code;
		extra->counter_simple = 0;
	}
	else {
		extra->counter_simple++;
		if(extra->counter_simple <= g_irr_simple_ignore_num){
			return -1;
		}
		else {
			extra->is_simcode = 1;
			extra->key_code = key_code;
		}
	}

	extra->key_code &= 0x1fff;
	return 0;
}

static int irr_parse_panasonic(gx_irr_extra*  extra)
{
    uint32_t i, sig_time, mark_time;
    uint8_t data0 = 0, data1 = 0;

    // 16 bit key code
    data0 = 0;
    for (i = 33; i < 41; i++)
    {
        mark_time = (extra->pulse_val[i] & 0xFFFF);
        sig_time  = (extra->pulse_val[i] >> 16);

        if(sig_time > (IRR_PROTCOL_TIME_PANASONIC * 3))
        {
            data0 |= (1<<(i-33));
        }
    }

    data1 = 0;
    for (i = 41; i < 49; i++)
    {
        mark_time = (extra->pulse_val[i] & 0xFFFF);
        sig_time  = (extra->pulse_val[i] >> 16);

        if(sig_time > (IRR_PROTCOL_TIME_PANASONIC * 3))
        {
            data1 |= (1<<(i-41));
        }
    }
    extra->key_code = (data0 <<24)|(data1<<8);

    return 0;
}

struct irr_algorithm gx_irr_algorithm =
{
    .functionality = irr_parse_default,
};

int irr_read(void *buffer, uint32_t *len)
{
    uint32_t *data = buffer;
    uint32_t size = *len;
    gx_irr_extra *extra = &irr_extra;
    struct irr_code_info_t irr_data;


retry:
    if (kfifo_len(extra->queue) == 0)
    {
        if((extra->irr_mode & O_NONBLOCK) == O_NONBLOCK)
        {
            return -1;
        }
        goto retry;
    }
    else
    {
        if (extra->algo->functionality == irr_parse_panasonic)
            mdelay(150);

        kfifo_get(extra->queue, (unsigned char *)&irr_data, sizeof(struct irr_code_info_t));

	size = (size <= sizeof(struct irr_code_info_t)) ? size : sizeof(struct irr_code_info_t);
	memcpy(data, (unsigned char *)&irr_data, size);

    }

    IRR_DBG("read_fifo key_code:0x%x\n",*(unsigned int *)data);

    return 0;
}

int irr_ioctl(uint32_t key, void *buf)
{
    gx_irr_extra *extra = &irr_extra;
    switch (key)
    {
        case IRR_NONBLOCK:
            extra->irr_mode = O_NONBLOCK;
            break;
        default:
            break;
    }
    return 0;
}

int irr_close(void)
{
    gx_irr_extra *extra = &irr_extra;
    volatile struct irr_regs *regs = (struct irr_regs *)extra->irr_base;

    regs->irr_cntl &= ~(1 << 9); //disable irr
#ifdef CONFIG_ENABLE_IRQ
    gx_free_interrupt(extra->irr_isrvec);
#endif
    return 0;
}

static int irr_protocol_detect( gx_irr_extra*  extra)
{
    uint32_t pulse_num = extra->pulse_num;
    uint32_t mark_time = 0;

    //¸ù¾ÝÂö³åµÄÊýÄ¿×ÔÊÊÓ¦²»Í¬µÄ±ê×¼
    if((IRR_MIN_PULSE_NUM_PHILIPS <= pulse_num
                && IRR_MAX_PULSE_NUM_PHILIPS >= pulse_num)
            || (IRR_MIN_PULSE_NUM_BESCON <= pulse_num
                && IRR_MAX_PULSE_NUM_BESCON >= pulse_num))
    {
        mark_time = (extra->pulse_val[0] & 0xFFFF);
        //besconµÄÆðÊ¼Î»¸ßµçÆ½ºãÎª420us
        if (2 * mark_time < IRR_PROTCOL_TIME_BESCON * 3
                && (2 * mark_time > IRR_PROTCOL_TIME_BESCON * 1))
        {
            //bescon±ê×¼
            extra->algo->functionality = irr_parse_bescon;
        }
        else
        {
            //philips±ê×¼
            extra->algo->functionality = irr_parse_philips;
        }
    }
    else if(IRR_MAX_SIMCODE_PULSE_NUM >= pulse_num
            || IRR_MAX_FULLCODE_PULSE_NUM <= pulse_num)
    {
        if(pulse_num >=49)
        {
            //ËÉÏÂ±ê×¼
            extra->algo->functionality = irr_parse_panasonic;
        }
        else if(pulse_num >=42)
        {
            extra->algo->functionality = irr_parse_dvb_40bit;
        }
        else if(pulse_num>=33)
        {
            //NEC±ê×¼
            extra->algo->functionality = irr_parse_nec;
        }
        else if(pulse_num <= IRR_MAX_SIMCODE_PULSE_NUM)
        {
            ;
        }
        else
        {
            //protocol not suported
            return -1;
        }
    }
    else
    {
        return -1;
    }
    return 0;
}

static void irr_get_fifo_data(gx_irr_extra*  extra)
{
    uint32_t i;
    volatile struct irr_regs *regs = (struct irr_regs *)extra->irr_base;
    unsigned int fifo_num = 0;
    unsigned int fifo_data = 0;
    unsigned int pulse_num = 0;
    unsigned int low_level = 0;
    unsigned int high_level = 0;

    fifo_num = regs->irr_fifo_ctrl & 0xFFFF;

#ifdef FIFO_TEST
    printf("fifo_num : %d\n", fifo_num);
#endif
    if(fifo_num > 128 )
	fifo_num = 128;

    for(i = 0; i < fifo_num; i++) {
        fifo_data = regs->irr_fifo_data & 0xFFFF;
	if (fifo_data & 0x8000)
		high_level = fifo_data & 0x7FFF;
	else
		low_level = fifo_data;
	if (high_level > 0 && low_level > 0) {
		if (pulse_num < IRR_MAX_PULSE_NUM) {
			extra->pulse_val[pulse_num] = high_level | ((high_level + low_level) << 16);
			pulse_num++;
		}
		high_level = 0;
		low_level = 0;
	}
    }

    extra->pulse_num = pulse_num;
}

#ifdef CONFIG_ENABLE_IRQ
static enum interrupt_return irr_interrupt_isr(uint32_t vector, void* pdata)
{
    gx_irr_extra*  extra   = & irr_extra;
    struct irr_code_info_t irr_data;
    volatile struct irr_regs *regs = (struct irr_regs *)extra->irr_base;

    IRR_DBG("status : %08x\n", regs->irr_intr_status);
    regs->irr_intr_enable = 0;
    regs->irr_intr_clr |= 1 | (1 << 1) | (1 << 2) | (1 << 4);
    regs->irr_cntl &= ~(1 << 9);
    gx_mask_interrupt(vector); //mask irr irq

    irr_get_fifo_data(extra);

    if (irr_protocol_detect(extra) < 0)
        goto exit;

    if (extra->algo->functionality(extra) < 0)
        goto exit;

    irr_data.code = extra->key_code;
    irr_data.is_simcode = extra->is_simcode;
    extra->is_simcode = 0;
    kfifo_put(extra->queue, (unsigned char *)&irr_data, sizeof(struct irr_code_info_t));


exit:
    gx_unmask_interrupt(vector);
#ifdef FIFO_TEST
    regs->irr_intr_enable |= IRR_INTR_FIFO_EN;
#else
    regs->irr_intr_enable |= IRR_INTR_TIMEOUT_EN;
#endif
    regs->irr_cntl |= 1 << 9;

    return HANDLED;
}
#endif

void irr_poll(void)
{
    gx_irr_extra*  extra   = & irr_extra;
    volatile struct irr_regs *regs = (struct irr_regs *)extra->irr_base;

    irr_get_fifo_data(extra);
    regs->irr_intr_enable = 0;
    regs->irr_intr_clr |= 1 | (1 << 1) | (1 << 2) | (1 << 4);
    regs->irr_cntl &= ~(1 << 9);

    if (irr_protocol_detect(extra) < 0)
        goto exit;

    if (extra->algo->functionality(extra) < 0)
        goto exit;

    IRR_DBG("key_code:0x%x\n", extra->key_code);
    kfifo_put(extra->queue, (unsigned char *)&extra->key_code, sizeof(uint32_t));


exit:
#ifdef FIFO_TEST
    regs->irr_intr_enable |= IRR_INTR_FIFO_EN;
#else
    regs->irr_intr_enable |= IRR_INTR_TIMEOUT_EN;
#endif
    regs->irr_cntl |= 1 << 9;
}

unsigned char irr_init(void)
{
    gx_irr_extra *extra = &irr_extra;
    uint32_t sys_clk = 0, irr_clk = 0;
    volatile struct irr_regs *regs;

    extra->irr_base = REG_BASE_IRR + 0x800;
#if defined(CONFIG_ARCH_ARM_SIRIUS)
    extra->irr_isrvec = 49;          //irr source number
#elif defined(CONFIG_ARCH_ARM_CANOPUS) || defined(CONFIG_ARCH_ARM_VEGA)
    extra->irr_isrvec = 56;          //irr source number
#elif defined(CONFIG_ARCH_ARM_VIRGO)
    extra->irr_isrvec = 94;          //irr source number
#else
    extra->irr_isrvec = 4;           //irr source number
#endif
    sys_clk = GX_EXT_CLOCK ;
    irr_clk = 1000*1000;

    regs = (struct irr_regs *)extra->irr_base;

    regs->irr_cntl &= ~(3 << 0);
    regs->irr_div = sys_clk / irr_clk - 1;
    regs->irr_level_time = 0;
    regs->irr_time_out = 20000; //timeout is 20ms
#ifdef FIFO_TEST
    regs->irr_fifo_ctrl = 0x7F << 16;
    regs->irr_intr_enable |= IRR_INTR_FIFO_EN;
#else
    regs->irr_intr_enable |= IRR_INTR_TIMEOUT_EN;
#endif
    regs->irr_cntl |= 1 << 9; //enable irr

    extra->algo = &gx_irr_algorithm;

    extra->queue = kfifo_alloc(IRR_KFIFO_SIZE);

#ifdef CONFIG_ENABLE_IRQ
    gx_request_interrupt(extra->irr_isrvec, IRQ, irr_interrupt_isr, NULL);
#endif

    return 0;
}

