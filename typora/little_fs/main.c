/*****************************************
  Copyright (c) 2002-2007
  Nationalchip Science & Technology Co., Ltd. All Rights Reserved
  Proprietary and Confidential
 *****************************************/

/* This file is part of the Nationalchip boot loader */
#include "stdio.h"
#include "string.h"

#include "config.h"
#include "util.h"
#include <gx_flash_common.h>
#include <flash.h>
#include "gx_flash.h"

#include "boot.h"
#include "gx_api.h"
#include "bootmenu.h"
#include "partition.h"
#include "time.h"
#include "serial.h"
#include "irr.h"
#include "interrupt.h"
#include "gpio.h"
#include "rcc.h"
#include "eeprom.h"
#include <scpu.h>
#include "version_autogenerated.h"
#include "chip_info.h"

#ifdef CONFIG_ENABLE_OTA
#include "gxota.h"
#endif

#ifdef CONFIG_ENABLE_NET
#include <net.h>
#endif

#ifdef CONFIG_ENABLE_CTR
#include  "ctr.h"
#endif

#ifdef CONFIG_ENABLE_IO_FRAMEWORK
#include "./ate/include/io.h"
#endif

#ifdef CONFIG_ENABLE_JTAG_PASSWD
#include "jtagpasswd.h"
#endif

#ifdef CONFIG_ENABLE_FIREWALL
#include "gx_firewall.h"
#endif

#ifdef CONFIG_ENABLE_UBI
#include "linux/mtd/mtd.h"
#endif
#include "cpu/cpu.h"

#include "user_config.h"
#include "gxloader_log.h"
#ifdef CONFIG_REE_LOADER
#include <gxteeloader_smccc.h>
#endif

extern void board_operation(void);

static void boot_init(void)
{
	unsigned long mem_start = 0;
	unsigned long mem_end   = 0;

	/* initialize heap */
	mem_start = HEAP_START_ADDR;
	mem_end   = HEAP_END_ADDR;
	heap_init((void *)mem_start, mem_end - mem_start);

#ifndef ENABLE_BOOT_TOOL
	mem_start = KERNEL_START_ADDR;
	mem_end   = KERNEL_END_ADDR;
	tmp_heap_init((void *)mem_start, mem_end - mem_start);
#endif

	cmdline_init(CONFIG_CMDLINE_VALUE);
}

void __attribute__((weak)) gx_power_reduction(void)
{

}

static int loader_init(void)
{
	int ret = 0;

	boot_init();

#if defined(CONFIG_REE_LOADER) && !defined(ENABLE_BOOT_TOOL)
	gxteeloader_init();
#endif

#ifdef CONFIG_ENABLE_IRQ
	gx_interrupt_init();
#endif

#ifdef CONFIG_ENABLE_TIME
	gx_time_init();
#endif

	arch_init();

	uart_init(CONFIG_UART_BAUDRATE, CONFIG_UART_PORT);

#ifdef CONFIG_ENABLE_MEMORY_PHASE_TEST
	printf("\n===stage2_phasetest===\n");
	extern void memory_phase_test(void);
	while (1) {
		memory_phase_test();
	}
#elif defined(CONFIG_ENABLE_MEMORY_TEST)
	printf("\n===stage2_memtest===\n");
	extern void memory_test(void);
	while (1) {
		memory_test();
	}
#elif defined(CONFIG_DDR_SOFT_TRAINING)
	switch_stack(STACK_TOP_ADDR, STAGE1_STACK_TOP_ADDR);
#endif

	gx_power_reduction();

#ifdef CONFIG_ENABLE_IO_FRAMEWORK
	io_framework_init();
	stdio_init();
#endif

	system_config_init();

#ifdef CONFIG_ENABLE_JTAG_PASSWD
	jtag_init();
#endif

#ifdef CONFIG_ENABLE_IRR
	irr_init();
#endif

#ifdef CONFIG_ENABLE_GPIO
	gx_gpio_init();
#endif

	gxflash_init();

#ifdef CONFIG_ENABLE_CTR
	gx_ctr_init();
#endif

#ifdef CONFIG_ENABLE_EEPROM
	if (eeprom_init(CONFIG_EEPROM_I2C_BUS_NUM, CONFIG_EEPROM_DEVICE_ADDR, CONFIG_EEPROM_TYPE))
		gxlogi("eeprom init error!\n");
#endif

#ifdef CONFIG_ENABLE_SCPU
	scpu_init();
#endif

#ifdef CONFIG_ENABLE_NET
	net_init();
#endif

#ifdef CONFIG_ENABLE_FIREWALL
	firewall_init();
#endif
#ifdef CONFIG_ENABLE_TEE
	permit_init();
#endif

	user_init();

	if(all_partition_init(NULL) != 0) {
		gxlogi("\nwarning! partition table no found, use default partition table:\n");
		ret = -1;
	}
	all_partition_printf();

#ifdef CONFIG_ENABLE_UBI
	mtd_probe_devices();
#endif

	return ret;
}

static void gx_print_info(void)
{
	char map[FLASH_TYPE_NUM];
	int i;
	int type;
#ifdef CONFIG_ENABLE_CHIP_INFO
	unsigned char *public_chip_id = NULL;
#endif

	type = flash_get_type();
	flash_get_used_device_map(map);
	/* shows greetings */
	gxlogi("\nGxLoader " LOADER_BANNER " \n\n");

#ifdef CONFIG_ENABLE_CHIP_INFO
	public_chip_id = gx_get_chip_id();
	if (public_chip_id == NULL)
		gxlogi("public id\t: 0000000000000000");
	else {
		gxlogi("public id\t: ");
		for (i = 0; i < GX_CHIP_ID_LEN; i++)
			gxlogi("%02x", public_chip_id[i]);
		gxlogi("\n");
	}
#endif
	gxlogi("cpu family\t: %s\n"     , CONFIG_ARCH);
	gxlogi("chip model\t: %s\n"     , CHIP_CORE);
	gxlogi("board type\t: %s\n"     , CHIP_BOARD);
	gxlogi("memory size\t: %lu MB\n", DRAM_SIZE / 1024 / 1024);
	for (i = 0; i < FLASH_TYPE_NUM; i++) {
		if (map[i] == 1) {
			flash_switch_type(i);
			gxlogi("Flash type\t: %s\n"     , gxflash_gettype());
			gxlogi("Flash size\t: %u MB\n"  , gxflash_get_info(GX_FLASH_CHIP_SIZE) >> 20);
		}
	}
	gx_print_allregisters();

	flash_switch_type(type);
}
#include "lfs.h"

// variables used by the filesystem
lfs_t lfs;
lfs_file_t file;

int lfs_spi_flash_read(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size) {
    // check if read is valid
    LFS_ASSERT(off % cfg->read_size == 0);
    LFS_ASSERT(size % cfg->read_size == 0);
    LFS_ASSERT(block < cfg->block_count);
    gxflash_readdata(0x300000+block * cfg->block_size + off, (uint8_t *)buffer, size);
    return LFS_ERR_OK;
}

/*
 * @brief 将数据写入指定块内的某区域。该区域必须已经先被擦除过，可以返回 LFS_ERR_CORRUPT 表示该块已损坏
 * @param [in] lfs_config格式参数
 * @param [in] block 逻辑块索引号，从0开始
 * @param [in] off 块内偏移，该值需能被rprog_size整除
 * @param [in] 写入数据的缓冲区
 * @param [in] size 要写入的字节数，该值需能被read_size整除，lfs在读取时会确保不会跨块；
 * @retval 0 成功, < 0 错误码
 */
int lfs_spi_flash_prog(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size) {
    // check if write is valid
    LFS_ASSERT(off % cfg->prog_size == 0);
    LFS_ASSERT(size % cfg->prog_size == 0);
    LFS_ASSERT(block < cfg->block_count);
    gxflash_pageprogram(0x300000+block * cfg->block_size + off, (uint8_t *)buffer, size);
    return LFS_ERR_OK;
}

/*
 * @brief 擦除指定块。块在写入之前必须先被擦除过，被擦除块的状态是未定义
 * @param [in] lfs_config格式参数
 * @param [in] block 要擦除的逻辑块索引号，从0开始
 * @retval 0 成功, < 0 错误码
 */
int lfs_spi_flash_erase(const struct lfs_config *cfg, lfs_block_t block) {
    // check if erase is valid
    LFS_ASSERT(block < cfg->block_count);
    gxflash_erasedata(0x300000+block * cfg->block_size, 64*1024);
    return LFS_ERR_OK;
}

/*
 * @brief 对底层块设备做同步操作。若底层块设备不没有同步这项操作可以直接返回
 * @param [in] lfs_config格式参数;
 * @retval 0 成功, < 0 错误码
 */
int lfs_spi_flash_sync(const struct lfs_config *cfg) {
    return LFS_ERR_OK;
}


// configuration of the filesystem is provided by this struct
const struct lfs_config cfg = {
    // block device operations
    .read  = lfs_spi_flash_read,
    .prog  = lfs_spi_flash_prog,
    .erase = lfs_spi_flash_erase,
    .sync  = lfs_spi_flash_sync,

    // block device configuration
    .read_size = 256,
    .prog_size = 256,
    .block_size = 64*1024,
    .block_count = 128,
    .cache_size = 512,
    .lookahead_size = 512,
    .block_cycles = 500,
};

// entry point
void test_littfs(void) {
    // mount the filesystem
    int err = lfs_mount(&lfs, &cfg);

    // reformat if we can't mount the filesystem
    // this should only happen on the first boot
    if (err) {
        lfs_format(&lfs, &cfg);
        lfs_mount(&lfs, &cfg);
    }

    // read current count
    uint32_t boot_count = 0;
    lfs_file_open(&lfs, &file, "boot_count", LFS_O_RDWR | LFS_O_CREAT);
    lfs_file_read(&lfs, &file, &boot_count, sizeof(boot_count));

    // update boot count
    boot_count += 1;
    lfs_file_rewind(&lfs, &file);
    lfs_file_write(&lfs, &file, &boot_count, sizeof(boot_count));

    // remember the storage is not updated until the file is closed successfully
    lfs_file_close(&lfs, &file);

    // release any resources we were using
    lfs_unmount(&lfs);

    // print the boot count
    printf("boot_count: %d\n", boot_count);
}


void __attribute__((section(".entry_text")))entry(uint32_t ddr_size)
{

	extern int __bss_start__, __bss_end__;

	/* clears BSS section */
	memset(&__bss_start__, 0, (uint32_t)&__bss_end__ - (uint32_t)&__bss_start__);

	loader_init();

	board_operation();

#ifdef CONFIG_PANEL
	extern int panel_show_call(void);
	panel_show_call();
#endif

	gx_print_info();

	g_start_time = gx_time_get_ms();

	if(g_board_extend.func_usb_update != NULL){
		g_board_extend.func_usb_update();
	}

#ifdef CONFIG_ENABLE_LOGO
	gx_show_logo();
#endif

#ifdef CONFIG_ENABLE_RELEASE_CHECK
	gx_release_check();
#endif
	test_littfs();

#ifdef CONFIG_ENABLE_CMD
	bootmenu();
#else
	simple_boot(0, NULL);
#endif
	while(1);
}
