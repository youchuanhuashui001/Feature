# 杂记

回调函数：回调函数是指一段以参数的形式传递给其它代码的可执行代码

- 回调函数的本质就是：程序员在编写程序的时候是不知道用户要拿来干什么的，用户需要干什么是他的自由，只需要让用户写好一个函数，在调用回调函数的时候把要干什么的函数当成参数传进程序员写的函数中即可。
- 只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其他模块才知道，因此我们必须把我们知道的封装成回调函数告诉其他模块

![image-20220301125155298](/home/tanxzh/txz/my/note/image/image-20220301125155298.png)

- 链接
  
  - 在一个c项目的编译中，编译器以C源文件为单位，将一个个C文件翻译成对应的目标文件。生成的每一个目标文件都是由代码段、数据段、BSS段、符号表等section组成的。这些section从目标文件的零偏移地址开始按照顺序依次排放，每个段中的符号相对于零地址的偏移，其实就是每个符号的地址。
  - 链接主要分为：分组组装、符号决议和重定位
    - 分组组装：将各个目标文件分段组装。连接器将编译器生成的各个可重定位目标文件重新分解组装，将各个目标文件的代码段放在一起，作为可执行文件的数据段。
    - 链接器会在可执行文件中创建一个全局符号表，每个可执行文件的所有符号都有自己的地址，并保存在全局符号表中，但此时全局符号表中的地址都还是原来在各个目标文件中的地址，即相对于零地址的偏移。
    - 程序在连接程序时需要制定一个链接起始地址，链接开始抵制一般也就是要加载到内存中的地址，使用链接脚本来指定程序的链接地址和各个段的组装顺序。
    - 通过符号决议来解决连接过程中多文件符号冲突的问题
    - 程序经过重新分解组装后，无论是代码段、数据段，各个符号的真实地址都发生了变化，而此时可执行文件的全局符号表中，各个符号的值还是原来的地址，所以还要更新真实地址到符号表中。
    - 重定位的核心工作就是修正指令中的符号地址

- 程序的运行过程，其实就是处理器根据PC寄存器汇总的地址，从内存中不断取指令、翻译指令和执行指令的过程。
  
  - 内存支持随机读写，因此可以支持cpu随机读取指令，ram断电不保存，rom断电保存
  - 因此采用RAM+ROM的方式，ROM常用来保存程序的指令和数据，但ROM不支持随机存取，因此程序运行时，会首先将指令和数据从ROm加载到RAM，然后CPU到RAM中取指令

- 静态库和动态库
  
  - 静态库：在编译时，链接器将引用的函数代码或变量，连接到可执行文件里，和可执行程序组装在一起，即在编译阶段链接的库
  - 动态库：当程序运行时才被加载到内存参与链接
    - 延迟绑定：当动态库中的函数第一次被调用到时，才会安保用到的动态库加载到内存中并进行重定位。
  - 当程序运行时，动态链接库首先被加载到内存运行，动态链接器会分析可执行文件，从可执行文件的.dynamaic段中查询该程序运行需要依赖的动态共享库，然后在库的默认路径下查找这些共享库，加载到内存中并进行动态链接，链接成功后将cpu的控制权交给可执行程序，程序就可以正常运行

- NOR Flash最大特点是支持XIP(Execute On Chip），既程序可以直接在NOR flash的片内执行，在NOR Flash中的代码运行时不需要重定位复制到SRAM内

- falsh的擦除一个扇区，是把这个扇区全部变成0xff

- 使用函数指针数组时，数组存储多个函数指针，在调用时要使用`handler[op]()`的方式调用，后面要加括号

- 内联函数
  
  - 一个函数在执行过程中，如果需要调用其它函数，则一般会执行以下过程：
    
    - 保存当前函数现场
    
    - 跳转到调用函数执行
    
    - 恢复当前函数现场
    
    - 继续执行当前函数
    
    - main在跳转到func()函数执行之前，先把R0寄存器的值保存到堆栈中，func()执行结束后，再把堆栈中的值恢复到R0寄存器，这样main()函数就可以继续执行了
  
  - 编译器在编译过程中遇到内联函数，像宏一样，将内联函数直接在调用出展开，在函数调用时直接执行内联函数展开的代码，不用保存现场和恢复现场

- 内联函数和宏
  
  - 内联相比于宏
    
    - 参数类型检查
    
    - 便于调试
    
    - 有返回值
    
    - 方便接口封装
  
  - 内联要保持：
    
    - 函数体积小
    
    - 函数体内无指针赋值、递归、循环等语句
    
    - 调用频繁

数据的存储位置：加载地址

数据要复制到哪里去：链接地址

当一个程序运行的时候，要去取数据，是去到链接地址取数据，所以要使用链接脚本把数据链接到正确的地方，否则都是脏数据
