#include <stdio.h>
#include <string.h>
#include "config.h"
#include "bootmenu.h"
#include "io.h"
#include "gxhwlib_registers.h"
#include "boot.h"
#include "romfs.h"
#include "commands.h"
#include "partition.h"
#include <gx_flash_common.h>
#include <flash.h>
#include "gx_flash.h"
#include "net.h"
#include "bootconfig.h"
#include "serial.h"
#include "time.h"
#include "gxota.h"
#include "fat.h"
#include "usb.h"
#include "rcc.h"
#include "eeprom.h"
#include "gx_otp.h"
#include "watchdog.h"
#include "gpio.h"
#include "gx_gpio.h"
#include "version_autogenerated.h"
#include "irr.h"
#include "time.h"
#include "i2c.h"

#ifdef CONFIG_ENABLE_INTC_NC
#include "drivers/intc/nationalchip/nc.h"
#endif
#ifdef CONFIG_ENABLE_UBI
#include "ubi_user.h"
#endif
#ifdef CONFIG_ENABLE_AXI_DMA
#include "gx_dma_axi.h"
#endif

extern int network_up(int force);

#define FLASHW_MSG "Specify address and data to be written\n"

static uint32_t _simple_crc32(uint32_t crc, const unsigned char * buf, int len)
{
	int i;
	unsigned char table[4] = {0x12, 0x34, 0x56, 0x78};

	for (i = 0; i < len; i++) {
		crc += buf[i] ^ table[i%4];
	}

	return crc;
}
static void _uart_crc_data_w(unsigned char *buf, int len)
{
	int i;
	union {
		uint32_t u32;
		uint8_t arr[4];
	} crc;

	// send "~sta~"
	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('s', CONFIG_UART_PORT);
	uart_putc('t', CONFIG_UART_PORT);
	uart_putc('a', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);

	// send data
	for(i = 0; i < len; i++)
		uart_putc(buf[i], CONFIG_UART_PORT);

	crc.u32 = _simple_crc32(0, buf, len);

	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('c', CONFIG_UART_PORT);
	uart_putc('r', CONFIG_UART_PORT);
	uart_putc('c', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);

	crc.u32 = htonl(crc.u32);
	for(i = 0; i < 4; i++)
		uart_putc(crc.arr[i], CONFIG_UART_PORT);

	// send "~fin~"
	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('f', CONFIG_UART_PORT);
	uart_putc('i', CONFIG_UART_PORT);
	uart_putc('n', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);
}

static int _uart_crc_data_r(unsigned char *buf, int len)
{
	int i;
	union {
		uint32_t u32;
		uint8_t arr[4];
	} crc;
	uint32_t buf_crc = 0;

	// send "~sta~"
	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('s', CONFIG_UART_PORT);
	uart_putc('t', CONFIG_UART_PORT);
	uart_putc('a', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);

	// rev data and calculate crc
	for(i = 0; i < len; i++)
		buf[i] = uart_getc(CONFIG_UART_PORT);

	buf_crc = _simple_crc32(0, buf, len);

	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('c', CONFIG_UART_PORT);
	uart_putc('r', CONFIG_UART_PORT);
	uart_putc('c', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);

	for(i = 0; i < 4; i++) {
		crc.arr[i] = uart_getc(CONFIG_UART_PORT);
	}
	crc.u32 = ntohl(crc.u32);

	if (crc.u32 != buf_crc) {
		printf("err: calc crc(0x%08x) != rcv crc(0x%08x)\n", buf_crc, crc.u32);
		return -1;
	}

	// send "~fin~"
	uart_putc('~', CONFIG_UART_PORT);
	uart_putc('f', CONFIG_UART_PORT);
	uart_putc('i', CONFIG_UART_PORT);
	uart_putc('n', CONFIG_UART_PORT);
	uart_putc('~', CONFIG_UART_PORT);
	return 0;
}

/******************************************** boot Command ********************************************/
COMMAND(boot, command_boot, "<partition name | flash address> -- boots kernel");
void command_boot(int argc, const char **argv)
{
	simple_boot(argc, argv);
}

/******************************************** bootp Command ********************************************/
#ifdef CONFIG_ENABLE_NET
COMMAND(bootp, command_bootp, "<server ip address> <file name> [load addr] - load memory and jump");
void command_bootp(int argc, const char **argv)
{
	in_addr_t ipaddr;
	unsigned int load_addr = LOAD_KERNEL_ADDR;
	char string_ip[20];

	if (network_up(0) != 0)
		;
	else if (argv[1] == NULL)
		printf("Specify IP address\n");
	else if (argv[2] == NULL)
		printf("Specify filename to download\n");
	else {
		if(argv[3] != NULL)
			load_addr = atoi(argv[3]);;
		memcpy(string_ip, argv[1], strlen(argv[1]) + 1);
		if (parse_ipaddr((char *)argv[1], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else {
			unsigned int len;

			if ((ipv4_tftp(ipaddr, g_bootconfig.tftp_port, TFTPOP_RRQ, (char *)argv[2], load_addr, &len)) == 0) {
				printf("tftp finished, %s: 0x%x 0x%x\n", string_ip, len, load_addr);
			}

#ifdef CONFIG_ENABLE_KERNEL_DTB
			run_kernel(load_addr, KERNEL_DTB_START_ADDR);
#else
			run_kernel(load_addr, 0);
#endif
		}
	}

}
#endif

/******************************************** Partition Command ********************************************/
#ifdef CONFIG_ENABLE_NET
COMMAND(config, command_config, "<conf> [options] - configures boot loader.");
void command_config(int argc, const char **argv)
{
	static int s_baudrate = CONFIG_UART_BAUDRATE;

	if (argc == 1) {
		return;
	}

	if (strcmp(argv[1], "tftpport") == 0) {
		g_bootconfig.tftp_port = atoi(argv[2]);
	}else if (strcmp(argv[1], "ip") == 0) {
		in_addr_t ipaddr;
		if (parse_ipaddr((char *)argv[2], &ipaddr) == 0 ) {
			g_bootconfig.ipaddr = ipaddr;
		}
	}else if (strcmp(argv[1], "serial") == 0) {
		static int s_validbaudrate[] = {
			9600, 19200, 38400, 57600, 115200, 230400, 0
		};

		int i, baudrate = CONFIG_UART_BAUDRATE;

		if (argv[2] == NULL)
			printf("Setup UART as default baud rate %d\n", baudrate);
		else {
			if (strcmp(argv[2], "fast") == 0)
				baudrate = 115200;
			else if (strncmp(argv[2], "def", 3) == 0)
				baudrate = 38400;
			else
				baudrate = atoi(argv[2]);

			for (i = 0; s_validbaudrate[i] != 0; ++i)
				if (s_validbaudrate[i] == baudrate)
					break;

			if (s_validbaudrate[i] == 0) {
				printf("Invalid baud rate %d\n", baudrate);
				baudrate = 0;
			} else
				printf("Setup UART baud rate: %d\n", baudrate);
		}

		if (baudrate) {
			s_baudrate = baudrate;
			uart_init(baudrate, CONFIG_UART_PORT);
		}
	} else
		printf("Unknown configuration\n");
}
#endif

/******************************************** Partition Command ********************************************/
COMMAND(partition, command_partition, "<partition name> <server ip> <filename> -- show flash partition list");
void command_partition(int argc, const char **argv)
{
	if (strcmp(argv[1], "show") == 0)
		partition_printf();
}

SUBCOMMAND(partition, erase, command_partition_erase, "<partition name> -- ...", 0);
void command_partition_erase(int argc, const char **argv)
{
	if (argc >= 3) {
		struct partition_info *p;
		p = all_partition_get(argv[2]);
		if (p) {
			if (gxflash_write_protect_unlock()) {
				printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
				return;
			}
			partition_erase(p);
			//partition_save();
		}
	}
}

/******************************************** WDTEST Command ********************************************/
#ifdef CONFIG_ENABLE_WDT
COMMAND(reboot,command_wdtest, "[time]  -- reboot after time,time unit is ms and default is 10ms");
void command_wdtest(int argc, const char **argv)
{
	int time = 0;

//	if(argc > 2){
//		printf("too many parameters, please read help.\n");
//		return;
//	}
	if(argc == 1){
		gx_wdt_reset_soon(10);
	}else if(argc == 2){
		time = atoi(argv[1]);
		gx_wdt_reset_soon(time);
	}else if(argc == 3) {
		time = atoi(argv[2]);
		gx_wdt_timer(time);
	}
}
#endif

#ifdef CONFIG_ENABLE_RTC
COMMAND(rtc,command_rtc, "[init/read/write/set_alarm]");
unsigned int tick1, tick2;
static int rtc_interrupt_callback(int irq, void *priv)
{
    gx_rtc_get_tick(&tick2);
    printf("RTC interrupt triggered!\n");
    printf("tick1: %ld, tick2: %ld, Difference: %ld\n", tick1, tick2, tick2 - tick1);
    return 0;
}

void command_rtc(int argc, const char **argv)
{
	unsigned int time = 0;
	int ret;

	if(strcmp(argv[1], "init") == 0){
		gx_rtc_init();
	}else if(strcmp(argv[1], "read") == 0){
		time = atoi(argv[1]);
		gx_rtc_get_tick(&time);
		printf("rtc time is %d\n", time);
	}else if(strcmp(argv[1], "write") == 0){
		time = atoi(argv[2]);
		gx_rtc_set_tick(time);
	}else if(strcmp(argv[1], "set_alarm") == 0){
		time = atoi(argv[2]);

		ret = gx_rtc_set_interrupt(rtc_interrupt_callback, NULL);
		if (ret != 0) {
			printf("Failed to set RTC interrupt callback\n");
			return ;
		}

		gx_rtc_get_tick(&tick1);

		ret = gx_rtc_set_alarm_time_s(time);
		if (ret != 0) {
			printf("Failed to set RTC alarm\n");
			return ;
		}
		printf("RTC alarm set for %d seconds\n", time);
	}
}
#endif

#ifdef CONFIG_ARCH_ARMV7
#include "linux/arm-smccc.h"
COMMAND(smc, command_smc, "smc --Secure Monitor Call");
void command_smc(int argc, const char **argv)
{
	struct arm_smccc_res res = {0};

	arm_smccc_smc(0,0,0,0,0,0,0,0,&res);

	printf("result = %08x\n", res.a0);
}
#endif

/****************************************** EEPROM Command ******************************************/
#ifdef CONFIG_ENABLE_EEPROM
SUBCOMMAND(eeprom, read, command_eeprom_read, "<eeprom address> <length> --read eeprom", 0);
void command_eeprom_read(int argc, const char **argv)
{
	unsigned int start_addr;
	int len;
	unsigned char *buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	start_addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);
	eeprom_read(buf, start_addr, len);

	_uart_crc_data_w(buf, len);

	free(buf);
}

SUBCOMMAND(eeprom, write, command_eeprom_write, "<eeprom address> <file name> --use boot tool write eeprom", 0);
void command_eeprom_write(int argc, const char **argv)
{
	unsigned int start_addr;
	int len;
	unsigned char *buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	start_addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);

	if (_uart_crc_data_r(buf, len)) {
		return ;
	}

	printf("Writing eeprom ... ");
	eeprom_write(buf, start_addr, len);
	printf("done\n");
	free(buf);
}
#endif

/******************************************** gx mtc Command ********************************************/
#if defined(CONFIG_ENABLE_MTC) && defined(CONFIG_ENABLE_MTC_TEST)
extern int mtc_test(int argc, const char *const argv[]);

SUBCOMMAND(mtc, sim_test, command_mtc_simple_test, "<soft/otp/calc/nds/mem> <de/en> <ecb/cbc/cfb/ofb/ctr>  <des/3des/aes128/aes192/aes256>", 0);
void command_mtc_simple_test(int argc, const char **argv)
{
	mtc_test(argc, argv);
}

SUBCOMMAND(mtc, com_test,  command_mtc_complete_test, "", 0);
void command_mtc_complete_test(int argc, const char **argv)
{
	mtc_test(argc, argv);
}
#endif

/******************************************** gx otp Command ********************************************/
#ifdef CONFIG_ENABLE_GX_OTP
SUBCOMMAND(gx_otp, tread, command_gx_otp_terminal_read, "<gx otp address> <length> --read gx otp", 0);
void command_gx_otp_terminal_read(int argc, const char **argv)
{
	int i;
	unsigned int start_addr;
	int len;
	unsigned char *buf;
	uint32_t crc;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	start_addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);

	gx_otp_read(start_addr,len,buf);
	crc = start_addr;
	crc = _simple_crc32(crc, buf, len);
	printf("read gx otp data: ");
	for(i = 0; i < len; i++)
	{
		printf("0x%02x ",buf[i]);
	}
	printf("0x%x\n", crc);


	free(buf);
}

SUBCOMMAND(gx_otp, read, command_gx_otp_read, "<gx otp address> <length> <file name> --read gx otp", 0);
void command_gx_otp_read(int argc, const char **argv)
{
	unsigned int start_addr;
	int len;
	unsigned char *buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	start_addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);
	gx_otp_read(start_addr,len,buf);

	_uart_crc_data_w(buf, len);

	free(buf);
}

#ifdef CONFIG_ENABLE_OTP_FULLFUNCTION
SUBCOMMAND(gx_otp, twrite, command_gx_otp_terminal_write, "<gx otp address> <hex digits string> --use boot tool write gx otp", 0);

void command_gx_otp_terminal_write(int argc, const char **argv)
{
	unsigned int start_addr;
	int len;
	int dest_len = 0;
	unsigned char *buf;
	unsigned char *dest_buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}

	dest_len = strlen(argv[3]);
	if (dest_len % 2) {
		dest_buf = malloc(dest_len + 1);
		*dest_buf++ = '0';
	} else
		dest_buf = malloc(dest_len);

	strcpy((char*)dest_buf, argv[3]);
	if (dest_len % 2)
		dest_buf--;

	start_addr = atoi(argv[2]);
	buf = string_to_hex((char *)dest_buf, &len);
	if (!buf) {
		printf("bad hex digits string, please read help.\n");
		return;
	}

	/* need crc value */
	if (argc == 5) {
		int i;
		uint32_t crc, rcv_crc;

		rcv_crc = (uint32_t)simple_strtoull(argv[4], NULL, 16);

		/* 对<gx otp address> <hex digits string>进行crc 计算 */
		crc = atoi(argv[2]);
		crc = _simple_crc32(crc, argv[3], strlen(argv[3]));

		if (crc != rcv_crc) {
			printf("calc string crc(0x%08x) != rcv crc(0x%08x)\n", crc, rcv_crc);
			return;
		}
		printf("check \"%s %s\" crc(0x%x) ok\n", argv[2], argv[3], crc);

	}

	gx_otp_write(start_addr,len,buf);
	free(buf);
	free(dest_buf);
	printf("write gx otp finish!\n");
}

SUBCOMMAND(gx_otp, write, command_gx_otp_write, "<gx otp address> <file name> --use boot tool write gx otp", 0);
void command_gx_otp_write(int argc, const char **argv)
{
	unsigned int i;
	unsigned int start_addr;
	int len;
	unsigned char *buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	start_addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);

	if (_uart_crc_data_r(buf, len)) {
		return ;
	}

	gx_otp_write(start_addr,len,buf);
	free(buf);
}
#endif
#endif

/******************************************** cmdline Command ********************************************/
COMMAND(cmdline, command_cmdline, "<operate> -- operate 'show' to show cmdline.");
void command_cmdline(int argc, const char **argv)
{
	if (strcmp(argv[1], "show") == 0) {
		printf("cmdline:%s\n", CONFIG_CMDLINE_VALUE);
	}else
		printf("ex. type 'cmdline show' to show cmdline.\n");

}

/* flags:0 normal mode; 1 write yaffs2 mode. */
static void flash_download(const char **argv, const char *buf, unsigned int len, int flags)
{
	struct partition_info *p = all_partition_get(argv[0]);
	if (gxflash_write_protect_unlock()) {
		printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
		return;
	}
	if (p != NULL) {
		if (len > p->partition_size)
			printf("out the partition size.\n");
		else {
			printf("Erase partition '%s' ...\n", argv[0]);
			partition_erase(p);
			printf("Write to partition '%s' ...\n", argv[0]);
			if(flags == 1)
				gxflash_pageprogram_yaffs2(p->start_addr, (unsigned char *)buf, len);
			else
				partition_write(p, 0, (unsigned char *)buf, len);
		}
	}
	else if (argv[0][0] >= '0' && argv[0][0] <= '9') {
		int flash_addr = atoi(argv[0]);
		if((flash_addr + len) > gxflash_get_info(GX_FLASH_CHIP_SIZE)){
			printf("error:flash_addr + download_size > flash_size, please confirm this error.\n");
			return;
		}
		if (flags == 1) { //yaffs2
			int page_size = 2 * 1024;
			int page_size_oob = page_size + 64;
			int erase_len = len / page_size_oob * page_size;
			printf("Erase flash address: 0x%x, len: %d\n", flash_addr, erase_len);
			gxflash_erasedata(flash_addr, erase_len);
			printf("Write to flash address: 0x%x, yaffs len: %d\n", flash_addr, len);
			gxflash_pageprogram_yaffs2(flash_addr, (uint8_t *)buf, len);
		} else { //normal
			printf("Erase flash address: 0x%x, len: %d\n", flash_addr, len);
			gxflash_erasedata(flash_addr, len);
			printf("Write to flash address: 0x%x, len: %d\n", flash_addr, len);
			gxflash_pageprogram(flash_addr, (uint8_t *)buf, len);
		}
	}
	else
		printf("Error flash address or partition name.\n");
}

static void flash_dump(const char **argv, const char *buf, unsigned int len)
{
	struct partition_info *p = all_partition_get(argv[0]);
	if (p != NULL) {
		if (len > p->total_size)
			printf("out the partition size.\n");
		else {
			printf("Write from partition '%s' ...\n", argv[0]);
			partition_read(p, 0, (unsigned char *)buf, len);
		}
	}
	else if (argv[0][0] >= '0' && argv[0][0] <= '9') {
		int flash_addr = atoi(argv[0]);
		if((flash_addr + len) > gxflash_get_info(GX_FLASH_CHIP_SIZE)){
			printf("error:flash_addr + download_size > flash_size, please confirm this error.\n");
			return;
		}
		printf("Write from flash address: 0x%x, len: %d\n", flash_addr, len);
		gxflash_readdata(flash_addr, (uint8_t*)buf, len);
	}
	else
		printf("Error flash address or partition name.\n");
}

static int is_nand_align_block(unsigned int addr)
{
#define NAND_BLOCK_SIZE (128*1024)
	if ((addr % NAND_BLOCK_SIZE) != 0)
		return 0;

	return 1;
}

static void nand_whole_bin_download(char *buf)
{
	struct partition mem_partition_entry;
	int i;
	unsigned int download_addr, download_size;
	unsigned int mem_start_addr, mem_addr;
	char str_addr[10];
	char *argv[1];//for flash_download arg

	if ((argv[0] = malloc(sizeof(str_addr))) == NULL) {
		printf("file: %s, line:%d, malloc error!\n", __FILE__, __LINE__);
		return;
	}
	mem_start_addr = (unsigned int)buf;
	if (mem_partition_init(buf, &mem_partition_entry) != 0) {
		printf("Search partition table fail!\n");
		return;
	}

	mem_partition_printf(&mem_partition_entry);

	for (i=0; i < mem_partition_entry.count; i++) {
		download_addr = mem_partition_entry.tables[i].start_addr;
		download_size = mem_partition_entry.tables[i].total_size;
		if (!is_nand_align_block(download_addr)) {
			printf("partition addr is not aligned. File: %s, Line: %d\n", __FILE__, __LINE__);
			return;
		}

		mem_addr = mem_start_addr + mem_partition_entry.tables[i].start_addr;
		sprintf(str_addr, "0x%x", download_addr);
		strncpy(argv[0], str_addr, sizeof(str_addr));
		if (mem_partition_entry.tables[i].file_system_type == YAFFS2)
			flash_download((const char **)argv, (char*)mem_addr, download_size, 1);
		else
			flash_download((const char **)argv, (char*)mem_addr, download_size, 0);
	}
}

#ifdef CONFIG_ENABLE_UBI
static int ubi_download(char *part_name, char *volume, char *buf, int len)
{
	if (ubi_part(part_name, NULL) < 0) {
		printf("ubi part failed\n");
		return -1;
	}

	printf("Write to part %s volume %s, len: %d\n", part_name, volume, len);
	ubi_volume_write(volume, buf, len);
}

static int ubi_dump(char *part_name, char *volume, char *buf, int len)
{
	if (ubi_part(part_name, NULL) < 0) {
		printf("ubi part failed\n");
		return -1;
	}

	printf("Read from part %s volume %s, len: %d\n", part_name, volume, len);
	ubi_volume_read(volume, buf, len);
}
#endif

/******************************************** Serialdown Command ********************************************/
COMMAND(serialdown, command_serialdown, "<partition name|flash addr> <download size> [yaffs|wholebin]-- download according serial. \
if you use boot tool, boot command: serialdown <partition name|flash addr> <file name>");
void command_serialdown(int argc, const char **argv)
{
	//boot command: serialdown <flash addr> <file name> [file offset] [file len]
	unsigned int len, i;
	char *buf;

	if(argc < 3){
		printf("arg not enough, please read help.\n");
		return;
	}
	len 		= atoi(argv[2]);

	buf = malloc(len);

	if (_uart_crc_data_r(buf, len)) {
		return ;
	}

	if (strcmp(argv[3], "wholebin") == 0 && flash_get_type() != 0)
		nand_whole_bin_download(buf);
	else if ((strcmp(argv[3], "yaffs") == 0) || (strcmp(argv[3], "yaffs2") == 0))
		flash_download(&argv[1], buf, len, 1);
#ifdef CONFIG_ENABLE_UBI
	else if (strcmp(argv[3], "ubi") == 0) {
		if (argc >= 5)
			ubi_download((char *)argv[1], (char *)argv[4], buf, len);
		else
			printf("error, ubi down need param volume name");
	}
#endif
	else
		flash_download(&argv[1], buf, len, 0);

	free(buf);
}

COMMAND(serialdump, command_serialdump, "<partition name|flash addr> <dump size> -- download according serial. \
if you use boot tool, boot command: serialdump <partition name|flash addr> <length> <file name>");
void command_serialdump(int argc, const char **argv)
{
	//boot command: serialdown <flash addr> <file name> [file offset] [file len]
	unsigned int len, i;
	char *buf, *tmp;

	if(argc < 3){
		printf("arg not enough, please read help.\n");
		return;
	}
	len 		= atoi(argv[2]);

	buf = malloc(len);
#ifdef CONFIG_ENABLE_UBI
	if (argc >= 5 && strcmp(argv[4], "ubi") == 0) {
		if (argc >= 6)
			ubi_dump((char *)argv[1], (char *)argv[5], buf, len);
		else
			printf("error, ubi dump need param volume name");
	} else
		flash_dump(&argv[1], buf, len);
#else
	flash_dump(&argv[1], buf, len);
#endif

	_uart_crc_data_w(buf, len);

	free(buf);
}

/******************************************** gdbdown Command ********************************************/
COMMAND(gdbdown, command_gdbdown, "<partition name|flash addr> <download size> [wholebin] [memory addr] -- download according jtag.");
void command_gdbdown(int argc, const char **argv)
{
	unsigned int len;
	char *buf;
	int whole_bin = 0;

	if(argc < 3){
		printf("arg not enough, please read help.\n");
		return;
	}

	buf = (char *)DRAMBASE;
	if (strcmp(argv[3], "wholebin") == 0)
		whole_bin = 1;

	if (argc == 4) {
		if (whole_bin == 0)
			buf = (char*)atoi(argv[3]);
	}
	else if (argc == 5) {
		buf = (char*)atoi(argv[4]);
	}

	len = atoi(argv[2]);

	if (whole_bin == 1 && flash_get_type() != 0)
		nand_whole_bin_download(buf);
	else
		flash_download(&argv[1], buf, len, 0);

	free(buf);
}

/******************************************** partition down Command ********************************************/
#ifdef CONFIG_ENABLE_NET
SUBCOMMAND(partition, download, command_partition_download, \
		"<partition name|flash addr> <server ipaddr> <filename> <file size> <yaffs|null> -- download image and write to partition", 0);
void command_partition_download(int argc, const char **argv)
{
	static char *dbuf = NULL;
	static int dtb_size = 0;
	if (network_up(0) != 0)
		;
	else if (argv[2] == NULL)
		printf("Specify Partition name\n");
	else if (argv[3] == NULL)
		printf("Specify IP address\n");
	else if (argv[4] == NULL)
		printf("Specify filename to download\n");
	else {
		in_addr_t ipaddr;

		if (parse_ipaddr((char *)argv[3], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else {
			char *p_buf = NULL;
			unsigned int file_len = 0;
			unsigned int transfer_len = 0;

			if(argv[5] == NULL){
				file_len = LOADER_START_ADDR - DRAMBASE;
				p_buf = (char *)DRAMBASE;	//in order to compatible with the old version boot, later will delete
			}else{
				file_len = atoi(argv[5]);
				p_buf = malloc(file_len);
				if(p_buf == NULL){
					printf("%s:%d malloc failed, malloc size=0x%x\n", __func__, __LINE__, atoi(argv[5]));
					return;
				}
			}

			while(1){
				if(icmp_ping(ipaddr, 1) > 0)
					break;
				printf("ping failed, please check the network hardware connection");
				printf(" and restart the board to try again.\n");
				net_dev_down();
				net_dev_up();
			}

			if ((ipv4_tftp(ipaddr, g_bootconfig.tftp_port, TFTPOP_RRQ, (char *)argv[4], (unsigned int)p_buf, &transfer_len)) == 0) {
				if (strcmp(argv[6], "dtb") == 0) {
					dbuf = (char *)malloc(transfer_len);
					dtb_size = transfer_len;
					memcpy(dbuf, p_buf, transfer_len);
					return;
				}
				printf("tftp finished %s. address: 0x%x,transfer_len: %d\n", argv[4], p_buf, transfer_len);
				if ((strcmp(argv[6], "yaffs") == 0) || (strcmp(argv[6], "yaffs2") == 0))
					flash_download(&argv[2], p_buf, transfer_len, 1);
#ifdef CONFIG_ENABLE_UBI
				else if (strcmp(argv[6], "ubi") == 0) {
					if (argc >= 8)
						ubi_download((char *)argv[2], (char *)argv[7], p_buf, transfer_len);
					else
						printf("error, ubi down need param volume name");
				}
#endif
				else if (dtb_size && ((strcmp(argv[6], "kernel") == 0))) {
					char *all_buf = (char *)malloc(transfer_len + dtb_size);
					memcpy(all_buf, dbuf, dtb_size);
					memcpy(all_buf+dtb_size, p_buf, transfer_len);
					flash_download(&argv[2], all_buf, dtb_size+transfer_len, 0);
					if (all_buf)
						free(all_buf);
					if (dbuf)
						free(dbuf);

				} else
					flash_download(&argv[2], p_buf, transfer_len, 0);
			}

			if(file_len < transfer_len){
				printf("warning: (malloc file len = %d) < (tftp transfer size = %d)\n", file_len, transfer_len);
			}

			if((unsigned int)p_buf != DRAMBASE)
				free(p_buf);
		}
	}
}

COMMAND(netdump, command_netdump, "<partition name|flash addr> <server ipaddr> <file name> <dump size> -- dump according net. ");
void command_netdump(int argc, const char **argv)
{
	int ret = -1;
	char *buf = NULL;
	loff_t actwrite_size = 0;
	unsigned int len;
	unsigned long nousd;

	if (argc < 5) {
		printf("error: parameters not enough(%d).\n", argc);
		return;
	}
	if (network_up(0) != 0)
		;
	else if (argv[1] == NULL)
		printf("Specify Partition name\n");
	else if (argv[2] == NULL)
		printf("Specify IP address\n");
	else if (argv[3] == NULL)
		printf("Specify filename to dump in\n");
	else if (argv[4] == NULL)
		printf("Specify length\n");
	else {
		in_addr_t ipaddr;
		if (parse_ipaddr((char *)argv[2], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else{
			len = atoi(argv[4]);
			buf = malloc(len);
			if (buf == NULL) {
				printf("error: malloc failed.\n");
				return;
			}
#ifdef CONFIG_ENABLE_UBI
			if (argc >= 6 && strcmp(argv[5], "ubi") == 0) {
				if (argc >= 7)
					ubi_dump((char *)argv[1], (char *)argv[6], buf, len);
			} else
				flash_dump(&argv[1], buf, len);
#else
			flash_dump(&argv[1], buf, len);
#endif
			while(1){
				if(icmp_ping(ipaddr, 1) > 0)
					break;
				printf("ping failed, please check the network hardware connection");
				printf(" and restart the board to try again.\n");
				net_dev_down();
				net_dev_up();
			}

			if ((ipv4_tftp(ipaddr, g_bootconfig.tftp_port, TFTPOP_WRQ, (char *)argv[3], (unsigned int)buf, &len)) == 0) {
				printf("tftp finished %s. Partition: %s,length: %d\n", argv[3], argv[1], len);
			}

			if((unsigned int)buf != DRAMBASE)
				free(buf);
			return;
		}
	}
}
#endif

struct info_list_struct {
	char *name;
	unsigned int addr;
};

void command_info_showlist(struct info_list_struct *list)
{
	int i;
	unsigned int data;

	for (i = 0; list[i].name != NULL; ++i) {
		data = __raw_readl(list[i].addr);
		printf("%08x : %s = %08x\n", list[i].addr, list[i].name, data);
	}
}

void show_gpio_status(unsigned int gpio_addr)
{
#ifdef CONFIG_GPIO_GX_V1
	int i;
	unsigned int data, mask;

	__raw_writel(0xffffffff, gpio_addr + GPIO_EPDDR);
	data = __raw_readl(gpio_addr + GPIO_EPDR);

	for (i = 0, mask = 1; i < 32; ++i, mask <<= 1)
		printf("GPIO0 %d : %d\n", i, (data & mask) ? 1 : 0);
#endif
}

COMMAND(info, command_info, "<class> - shows information on specified class");
void command_info(int argc, const char **argv)
{
	static struct info_list_struct s_irq_info_list[] = {
#ifdef CONFIG_ENABLE_INTC_NC
		{"IRQ_STATUS"          , REG_INTC_BASE + INTC_NINT},
		{"IRQ_PENDSTAT"        , REG_INTC_BASE + INTC_NPEND},
		{"IRQ_ENABLESET"       , REG_INTC_BASE + INTC_NENSET},
		{"IRQ_STATUS_HI"       , REG_INTC_BASE + INTC_NINT2},
		{"IRQ_PENDSTAT_HI"     , REG_INTC_BASE + INTC_NPEND2},
		{"IRQ_ENABLESET_HI"    , REG_INTC_BASE + INTC_NENSET2},
#endif
		{NULL, 0},
	};

	static struct info_list_struct s_fiq_info_list[] = {
#ifdef CONFIG_ENABLE_INTC_NC
		{"FIQ_STATUS"          , REG_INTC_BASE + INTC_FINT},
		{"FIQ_PENDSTAT"        , REG_INTC_BASE + INTC_FPEND},
		{"FIQ_ENABLESET"       , REG_INTC_BASE + INTC_FENSET},
		{"FIQ_STATUS_HI"       , REG_INTC_BASE + INTC_FINT2},
		{"FIQ_PENDSTAT_HI"     , REG_INTC_BASE + INTC_FPEND2},
		{"FIQ_ENABLESET_HI"    , REG_INTC_BASE + INTC_FENSET2},
#endif
		{NULL, 0},
	};

#ifdef CONFIG_ENABLE_SFLASH
	static struct info_list_struct s_sflash_info_list[] = {
#ifdef CONFIG_ENABLE_GXSPI
#define SFLA_SPI_CR                 0x00
#define SFLA_SPI_SR                 0x04
#define SFLA_SPI_TX_DATA            0x08
#define SFLA_SPI_RX_DATA            0x0c

		{"SFLA_SPI_CTRL"       , REG_BASE_SPI + SFLA_SPI_CR},
		{"SFLA_SPI_STATUS"     , REG_BASE_SPI + SFLA_SPI_SR},
		{NULL, 0},
#endif
	};
#endif

	static struct info_list_struct s_dram_info_list[] = {
		{"DRAM_TIMING_CFG"     , REG_BASE_DRAM + TIMING_CONFIG},
		{"DRAM_DRAM_CFG"       , REG_BASE_DRAM + DRAM_CONFIG},
		{"DRAM_PAD_CFG"        , REG_BASE_DRAM + PAD_CONFIG},
		{NULL, 0},
	};

	if (argc == 1) {
		printf("info parameters not enough. please type info <class>.\n");
		return;
	}

	if (strcmp(argv[1], "irq") == 0) {
		command_info_showlist(s_irq_info_list);
	} else if (strcmp(argv[1], "fiq") == 0) {
		command_info_showlist(s_fiq_info_list);
#ifdef CONFIG_ENABLE_SFLASH
	} else if (strcmp(argv[1], "sflash") == 0) {
		command_info_showlist(s_sflash_info_list);
#endif
	} else if (strcmp(argv[1], "dram") == 0) {
		command_info_showlist(s_dram_info_list);
	} else if (strcmp(argv[1], "gpio") == 0) {
		unsigned int addr;
		for (addr = REG_BASE_GPIO1; addr <= REG_BASE_GPIO3; addr += 0x1000)
			show_gpio_status(addr);
	} else{
		printf("info %s not support.\n", argv[1]);
	}

}

/******************************************** Memrory Command ********************************************/
#ifdef CONFIG_ENABLE_MEMORY
COMMAND(mem, command_mem, "<op> [args] - reads from or writes to memory");
void command_mem(int argc, const char **argv)
{
	int read, len;
	unsigned int addr, data = 0;

	if (argc == 1)
		return;
	if (strncmp(argv[1], "find", 4) == 0) {
		unsigned int from = DRAMBASE;
		unsigned int to = DRAMBASE + DRAM_SIZE;

		unsigned int data;
		uint8_t data8 = 0, *ptr8, *ptr8_to;
		uint16_t data16 = 0, *ptr16, *ptr16_to;
		uint32_t data32 = 0, *ptr32, *ptr32_to;

		switch (argv[1][4]) {
			case 'b':
				len = 1;
				break;
			case 'w':
				len = 2;
				break;
			case 'l':
				len = 4;
				break;
			default:
				len = -1;
				break;
		}

		if (len < 0) {
			printf("Invalid data type\n");
			return;
		}

		if (argv[2] == NULL) {
			printf("Specify value to find\n");
			return;
		}
		else {
			data = atoi(argv[2]);
			data <<= (32 - (len * 8));
			data >>= (32 - (len * 8));
		}

		if (argv[3])
			from = atoi(argv[3]);
		if (argv[4])
			to = atoi(argv[4]);

		printf("Searching value 0x%x between 0x%08x-0x%08x\n", data, from, to);

		switch (len) {
			case 1:
				data8 = data;
				ptr8 = (uint8_t *) from;
				ptr8_to = (uint8_t *) to;

				while (ptr8 < ptr8_to) {
					if (*ptr8 == data8) {
						printf("Found value 0x%02x @ 0x%08x\n", data, (unsigned int)ptr8);
						return;
					}
					++ptr8;
				}
				break;
			case 2:
				data16 = data;
				ptr16 = (uint16_t *) from;
				ptr16_to = (uint16_t *) to;

				while (ptr16 < ptr16_to) {
					if (*ptr16 == data16) {
						printf("Found value 0x%04x @ 0x%08x\n", data, (unsigned int)ptr16);
						return;
					}
					++ptr16;
				}
				break;
			case 4:
				data32 = data;
				ptr32 = (uint32_t *) from;
				ptr32_to = (uint32_t *) to;

				while (ptr32 < ptr32_to) {
					if (*ptr32 == data32) {
						printf("Found value 0x%08x @ 0x%08x\n", data, (unsigned int)ptr32);
						return;
					}
					++ptr32;
				}
				break;
		}

		printf("Not found\n");

		return;
	}
	else if (strcmp(argv[1], "clear") == 0) {
		return;
	}

	if ((argv[1][0] == 's') && (argv[1][1] == 'u') && (argv[1][2] == 'm')) {
		unsigned int size, sum;
		if (argc != 4) {
			printf("Specify addr and size\n");
			return;
		}

		addr = atoi(argv[2]);
		size = atoi(argv[3]);
		sum = binfile_crc_check((void *)addr, size);
		printf("Sum is 0x%08x\n", sum);
		return;
	}

	switch (argv[1][0]) {
		case 'r':
			read = 0;
			break;
		case 'w':
			read = 1;
			break;
		default:
			read = -1;
			break;
	}

	switch (argv[1][1]) {
		case 'b':
			len = 1;
			break;
		case 'w':
			len = 2;
			break;
		case 'l':
			len = 4;
			break;
		default:
			len = -1;
			break;
	}

	if (read == -1 || len == -1 || argv[1][2] != 0) {
		printf("Invalid operation\n");
		return;
	}

	if (argc == 2) {
		printf("Specify address\n");
		return;
	}

	addr = atoi(argv[2]);

	if (read == 0) {
		switch (len) {
			case 1:
				data = __raw_readb(addr);
				break;
			case 2:
				data = __raw_readw(addr);
				break;
			case 4:
				data = __raw_readl(addr);
				break;
		}

		printf("Read %d : Addr = %08x, Data = %0*x (%d)\n", len, addr, len * 2, data, data);
	}
	else {
		if (argc == 3) {
			printf("Specify data\n");
			return;
		}

		data = atoi(argv[3]);

		switch (len) {
			case 1:
				__raw_writeb(data, addr);
				break;
			case 2:
				__raw_writew(data, addr);
				break;
			case 4:
				__raw_writel(data, addr);
				break;
		}

		printf("Write %d : Addr = %08x, Data = %0*x (%d)\n", len, addr, len * 2, data, data);
	}
}

COMMAND(memtest, command_memtest, "run the linux memtest code");
void command_memtest(int argc, const char **argv)
{
	extern void memory_test(void);
	memory_test();
}

COMMAND(memcmp, command_memcmp, "<addr1> <addr2> [len] - compares memory region");
void command_memcmp(int argc, const char **argv)
{
	unsigned int i, addr1, addr2, len = 0x100;
	unsigned char *ptr1, *ptr2;
	unsigned int ndiff = 0, firstdiff = 0;

	if (argc == 1) {
		return;
	}

	if (argc < 3) {
		printf("Specify addresses to compare\n");
		return;
	}

	addr1 = atoi(argv[1]);
	addr2 = atoi(argv[2]);
	if (argc >= 4)
		len = atoi(argv[3]);

	ptr1 = (unsigned char *)addr1;
	ptr2 = (unsigned char *)addr2;

	for (i = 0; i < len; ++i) {
		if (ptr1[i] != ptr2[i]) {
			if (ndiff++ == 0)
				firstdiff = i;
		}
	}

	if (ndiff == 0)
		printf("No difference\n");
	else {
		printf("Found %d differences\n", ndiff);
		printf("First diff. @ %08x : %02x %02x\n", firstdiff, ptr1[firstdiff], ptr2[firstdiff]);
	}
}

COMMAND(memcpy, command_memcpy, "<to> <from> [len] - copies memory region");
void command_memcpy(int argc, const char **argv)
{
	unsigned int to, from, len = 0x100;

	if (argc == 1) {
		return;
	}

	if (argc < 3) {
		printf("Specify addresses to copy\n");
		return;
	}

	to = atoi(argv[1]);
	from = atoi(argv[2]);
	if (argc >= 4)
		len = atoi(argv[3]);

	memcpy((void *)to, (void *)from, len);

	printf("Copy completed\n");
}

SUBCOMMAND(memcpy, speed, memcpy_speed_cmd, "[len] [cnt] - calc memcpy speed, default 0x10000 100", 0);
void memcpy_speed_cmd(int argc, const char **argv)
{
	int i;
	void *to = NULL, *from = NULL;
	unsigned int len = 0x10000;
	unsigned int cnt = 100;
	unsigned int start_ms, end_ms;

	if(argc < 2){
		printf("parameters not enough.\n");
		return;
	}else if(argc == 3){
		len = atoi(argv[2]);
	}else if(argc >= 4){
		len = atoi(argv[2]);
		cnt = atoi(argv[3]);
	}

	to = malloc(len);
	from = malloc(len);
	if((to == NULL) || (from == NULL)){
		printf("%s:%d malloc failed.\n", __func__, __LINE__);
		return;
	}
	printf("to=0x%x from=0x%x len=0x%x cnt=%d\n", to, from, len, cnt);
	start_ms = gx_time_get_ms();
	for(i = 0; i < cnt; i++){
		memcpy((void *)to, (void *)from, len);
	}
	end_ms = gx_time_get_ms();
	printf("test time = %dms, test speed = %dKB/s\n", end_ms - start_ms, len * cnt / 1024 * 1000 / (end_ms - start_ms));
	printf("Copy completed\n");
	free(to);
	free(from);
}
#endif

/******************************************** Flash Command ********************************************/
COMMAND(flash, command_flash, "<command> [args...] - flash operation");
void command_flash(int argc, const char **argv)
{
	char *cmd;

	if(argv[1] == NULL){
		printf("flash command insufficient parameters. please type 'flash help'.\n");
#ifdef CONFIG_ENABLE_FLASH_TEST
		printf("test command list:\n");
		printf("flash comtest <cnt=1000>\n");
		printf("flash capacitytest\n");
		printf("flash multiprogramtest\n");
		printf("flash sectortest\n");
		printf("flash wptest\n");
		printf("flash wplock <len>\n");
		printf("flash wpstatus\n");
		printf("flash otptest [region]\n");
		printf("flash otplock\n");
		printf("flash otpstatus\n");
		printf("flash speedtest\n");
		printf("flash uid\n");
		printf("flash ecctest\n");
		printf("flash bitflip <addr> <len> <bitflips>\n");
		printf("flash worntest [addr]\n");
		printf("flash powercuttest\n");
		printf("flash powercuttestinit\n");
		printf("flash randomseed\n");
		printf("flash singletest <addr> <len>\n");
		printf("flash testcase\n");
		printf("flash markbadblock <addr>\n");
		printf("flash recoverbadblock <addr>\n");
		printf("flash ecc2test\n");
		printf("flash nandcomtest [cnt]\n");
		printf("flash nandsingletest <addr> <len> <oobaddr> <ooblen> <mode>\n");
		printf("flash sample_delay <clk_div>\n");

#endif
		goto gxflash_out;
	}

	cmd = (char *)argv[1];

	if (strcmp(argv[1], "probe") == 0) {
		gxflash_init();
	}
	else if (strcmp(argv[1], "forcelist") == 0) {
		goto gxflash_out;
	}
#ifdef CONFIG_ENABLE_FLASH_TEST
	else if (strcmp(argv[1], "comtest") == 0) {
		unsigned int count = 1000;
		if (argc > 2) {
			count = atoi(argv[2]);
		}
		flash_complete_test(count);
	}
	else if (strcmp(argv[1], "info") == 0) {
		flash_info_test();
	}
	else if (strcmp(argv[1], "oobtest") == 0) {
		flash_oob_test();
	}
	else if (strcmp(argv[1], "capacitytest") == 0) {
		flash_capacity_test();
	}
	else if (strcmp(argv[1], "multiprogramtest") == 0) {
		flash_multi_proram_test();
	}
	else if (strcmp(argv[1], "sectortest") == 0) {
		flash_nor_sector_erase_test();
	}
	else if (strcmp(argv[1], "worntest") == 0) {
		unsigned int addr = 0;
		if (argc > 2) {
			addr = atoi(argv[2]);
		}
		flash_nand_ecc_buildin_worn_test(addr);
	}
	else if (strcmp(argv[1], "bitflip") == 0) {
		unsigned int addr, len, bitflips;
		if (argc == 5) {
			addr     = atoi(argv[2]);
			len      = atoi(argv[3]);
			bitflips = atoi(argv[4]);
			flash_nand_bitflip_test(addr, len, bitflips);
		} else
			printf("flash bitflip <addr> <len> <bitflips>\n");
	}
	else if (strcmp(argv[1], "ecctest") == 0) {
		flash_nand_ecc_test();
	}
	else if (strcmp(argv[1], "ecc2test") == 0) {
			flash_nand_ecc2_test();
	}
	else if (strcmp(argv[1], "wptest") == 0) {
		flash_wp_test();
	}
	else if (strcmp(argv[1], "wplock") == 0) {
		int len;
		if (argc == 3) {
			len = atoi(argv[2]);
			flash_wplock(len);
		} else
			printf("flash wplock <len>\n");
	}
	else if (strcmp(argv[1], "wpstatus") == 0) {
		flash_wp_status();
	}
	else if (strcmp(argv[1], "otptest") == 0) {
		int page;
		if (argc == 3)
			page = atoi(argv[2]);
		else
			page = -1;
		flash_otp_test(page);
	}
	else if (strcmp(argv[1], "otpwrite") == 0) {
		int page;
		page = atoi(argv[2]);
		flash_otp_write_page(page);
	}
	else if (strcmp(argv[1], "otpread") == 0) {
		int page;
		page = atoi(argv[2]);
		flash_otp_read_page(page);
	}
	else if (strcmp(argv[1], "otplock") == 0) {
		gxflash_otp_lock();
	}
	else if (strcmp(argv[1], "otpstatus") == 0) {
		flash_otp_test_status();
	}
	else if (strcmp(argv[1], "speedtest") == 0) {
		flash_speed_test();
	}
	else if (strcmp(argv[1], "uid") == 0) {
		flash_uid_test();
	}
	else if (strcmp(argv[1], "all0") == 0) {
		flash_all0();
	}
	else if (strcmp(argv[1], "powercuttest") == 0) {
		flash_power_cut_test();
	}
	else if (strcmp(argv[1], "powercuttestinit") == 0) {
		flash_power_cut_test_init();
	}
	else if (strcmp(argv[1], "randomseed") == 0) {
		int seed;
		if (argc == 3)
			seed = atoi(argv[2]);
		else
			seed = 1;
		rand_init(seed);
	}
	else if (strcmp(argv[1], "testcase") == 0) {
		gxflash_exec_testcase();
	}
	else if (strcmp(argv[1], "singletest") == 0) {
		unsigned int addr, len;
		if (argc == 4) {
			addr     = atoi(argv[2]);
			len      = atoi(argv[3]);
			sflash_test_single(addr, len);
		} else
			printf("flash singletest <addr> <len>\n");
	}
	else if (strcmp(argv[1], "markbadblock") == 0) {
		unsigned int addr = 0;
		if (argc == 3) {
			addr = atoi(argv[2]);
			mark_bad_block_test(addr);
		}else
			printf("flash markbadblock <addr>\n");
	}
	else if (strcmp(argv[1], "recoverbadblock") == 0) {
		unsigned int addr = 0;
		if (argc == 3) {
			addr = atoi(argv[2]);
			recover_bad_block_test(addr);
		}else
			printf("flash recoverbadblock <addr>\n");
	}else if (strcmp(argv[1], "nandcomtest") == 0) {
		unsigned int count = 1000;
		if (argc > 2) {
			count = atoi(argv[2]);
		}
		flash_nand_complete_test(count);
	}else if (strcmp(argv[1], "nandsingletest") == 0) {
		unsigned int addr, len, oobaddr, ooblen, mode;
		if (argc == 7) {
			addr     = atoi(argv[2]);
			len      = atoi(argv[3]);
			oobaddr  = atoi(argv[4]);
			ooblen   = atoi(argv[5]);
			mode     = atoi(argv[6]);
			flash_nand_test_single(addr, len, oobaddr, ooblen, mode);
		} else
			printf("flash nandsingletest <addr> <len> <oobaddr> <ooblen> <mode>\n");
	}
#ifdef CONFIG_ENABLE_FIREWALL
	else if (strcmp(argv[1], "firewall_test") == 0) {
		unsigned int addr = 0;
		unsigned int len = 0;
		unsigned int r = 0, w = 0;
		if (argc == 6) {
			addr = atoi(argv[2]);
			len = atoi(argv[3]);
			r = atoi(argv[4]);
			w = atoi(argv[5]);
			flash_firewall_test(addr, len, r, w);
		} else {
			printf("flash firewall_test <addr> <len> <read_permission> <write_permission>\n");
		}
	}
#endif
#if (defined(CONFIG_ENABLE_DWSPI) && defined(CONFIG_ENABLE_SFLASH)) || (defined(CONFIG_ENABLE_DWSPI) && defined(CONFIG_ENABLE_SPINAND))
	else if (strcmp(argv[1], "sample_delay") == 0) {
		unsigned int clk_div;

		if (argc == 3) {
			clk_div = atoi(argv[2]);
			if (clk_div < 2)
				clk_div = 2;
			flash_sample_delay_test(clk_div);
		} else
			printf("flash sample_delay <clk_div>\n");
	}
#endif
#endif

#ifdef CONFIG_ENABLE_FLASH_FULLFUNCTION
	else if (strcmp(argv[1], "lock") == 0) {
		unsigned int addr;

		if (argv[2] == NULL)
			goto gxflash_out;

		addr = atoi(argv[2]);
		gxflash_write_protect_lock(addr);
	}
	else if (strcmp(argv[1], "unlock") == 0) {
		if (gxflash_write_protect_unlock()) {
			printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
			return;
		}
	}
	else if (strcmp(argv[1], "badinfo") == 0) {
		gxflash_badinfo();
	}
	else if (!strcmp(argv[1], "readb")) {
		unsigned int addr;
		unsigned char indata;

		if (argc < 3) {
			printf(FLASHW_MSG);
			goto gxflash_out;
		}

		addr = atoi(argv[2]);

		gxflash_readdata(addr, &indata, 1);
		printf("%08x : %02x => \n", addr, indata);
	}
	else if (!strcmp(argv[1], "test")) {
		gxflash_test((int)(argc - 2),(char**)( argv + 2));
		while(1);
	}
#endif
	else
		printf("Unknown command\n");

gxflash_out:
	;
}

SUBCOMMAND(flash, switch, flash_switch_cmd, "<type> : type 0:spinor 1:spinand 2:normal nand 3:extend spinor", 0);
void flash_switch_cmd(int argc, const char **argv)
{
	if(argc == 3)
		flash_switch_type(atoi(argv[2]));
	else
		printf("error: parameters error.\n");
}

#ifdef CONFIG_ENABLE_FLASH_FULLFUNCTION
SUBCOMMAND(flash, writeb, flash_writeb, "<addr> <data> : writes one byte of data into specified address", 0);
void flash_writeb(int argc, const char **argv)
{
	unsigned int addr;
	unsigned char data, indata;

	if (argc < 4) {
		printf(FLASHW_MSG);
		return;
	}

	addr = atoi(argv[2]);
	data = (unsigned char)atoi(argv[3]);

	gxflash_readdata(addr, &indata, 1);
	printf("%08x : %02x => ", addr, indata);
	if (gxflash_write_protect_unlock()) {
		printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
		return;
	}
	gxflash_pageprogram(addr, &data, 1);
	gxflash_readdata(addr, &indata, 1);
	printf("%02x\n", indata);
}

SUBCOMMAND(flash, read, flash_read, "<flash addr> <memory addr> <length> -- read data from flash to memory", 0);
void flash_read(int argc, const char **argv)
{
	unsigned int ramaddr, flashaddr, len;
	uint32_t j = 0;

	if (argc < 5) {
		printf(FLASHW_MSG);
		return;
	}

	flashaddr = atoi(argv[2]);
	ramaddr = atoi(argv[3]);
	len = atoi(argv[4]);

	gxflash_readdata(flashaddr, (unsigned char *)ramaddr, len);
	for (j = 0; j < len; j++) {
		printf("%02x ", ((unsigned char *)ramaddr)[j]);
		if((j+1)%16 == 0)
			printf("\n");
	}

	printf("\n");
}

SUBCOMMAND(flash, write, flash_write, "<flash addr> <memory addr> <length> -- writes block of data into specified address", 0);
void flash_write(int argc, const char **argv)
{
	unsigned int to, from, len;

	if (argc < 5) {
		printf(FLASHW_MSG);
		return;
	}

	to = atoi(argv[2]);
	from = atoi(argv[3]);
	len = atoi(argv[4]);

	printf("Writing... ");
	if (gxflash_write_protect_unlock()) {
		printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
		return;
	}
	gxflash_pageprogram(to, (unsigned char *)from, len);
	printf("done\n");
}

SUBCOMMAND(flash, eraseall, flash_eraseall, " -- erases all serial flash memory", 0);
void flash_eraseall(int argc, const char **argv)
{
	printf("Erasing... ");
	if (gxflash_write_protect_unlock()) {
		printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
		return;
	}
	gxflash_chiperase();
	printf("done\n");
}

SUBCOMMAND(flash, erase, flash_erase, "<partition name> |[nospread] <addr> <length> -- erases one or more sectors of serial flash memory", 0);
void flash_erase(int argc, const char **argv)
{
	unsigned int addr, start, end, len = 1;
	unsigned int nospread = 0;

	if (argc < 3) {
		printf("Specify partition or address and length to erase\n");
		return;
	}
	else if(argc == 3) {
		struct partition_info *p = all_partition_get(argv[2]);
		if (p != NULL) {
			printf("Erase partition '%s' ...\n", argv[2]);
			if (gxflash_write_protect_unlock()) {
				printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
				return;
			}
			partition_erase(p);
		}
		else
			printf("Error partition name.\n");
	}
	else {
		if (strcmp(argv[2], "nospread") == 0)
			nospread = 1;
		if (nospread) {
			if (argc < 5) {
				printf("parameters not enough.\n");
				return;
			}
			addr = atoi(argv[3]);
			len = atoi(argv[4]);
		} else {
			addr = atoi(argv[2]);
			len = atoi(argv[3]);
		}

		gxflash_calcblockrange(addr, len, &start, &end);
		printf("Erasing...\n");
		if (gxflash_write_protect_unlock()) {
			printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
			return;
		}
		if (nospread)
			gxflash_erasedata_nospread(addr, len);
		else
			gxflash_erasedata(addr, len);
		printf("done\n");
	}
}

#if defined(CONFIG_ENABLE_SPINAND) || defined(CONFIG_ENABLE_NANDFLASH) || defined(CONFIG_ENABLE_ADAPTIVE_FLASH)
SUBCOMMAND(flash, scrub, flash_scrub, "all | <addr> <length> -- DANGEROUS!!! scrub option will erase all factory set bad blocks, there is no reliable way to recover them", 0);
void flash_scrub(int argc, const char **argv)
{
	unsigned int addr, len = 1;

	if (argc < 3) {
		printf("Specify scrub all or scrub address length to scrub\n");
		return;
	}
	else if(argc == 3) {
		if (strcmp(argv[2], "all") != 0) {
			printf("Specify scrub all or scrub address length to scrub\n");
			return;
		}
		printf("scrub all...\n");
		if (gxflash_write_protect_unlock()) {
			printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
			return;
		}

		gxflash_scruberase(0, gxflash_get_info(GX_FLASH_CHIP_SIZE));
	} else {
		addr = atoi(argv[2]);
		len = atoi(argv[3]);
		printf("scrub addr 0x%08x len %d...\n", addr, len);
		if (addr >= gxflash_get_info(GX_FLASH_CHIP_SIZE)) {
			printf("scrub address is over the flash size\n");
			return;
		}
		if (gxflash_write_protect_unlock()) {
			printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
			return;
		}
		gxflash_scruberase(addr, len);
		printf("done\n");
	}
}

SUBCOMMAND(flash, markbad, flash_markbad, "addr -- create an artificial bad block (for testing bad block handling)", 0);
void flash_markbad(int argc, const char **argv)
{
	unsigned int addr;

	if (argc < 3) {
		printf("Specify address to markbad\n");
		return;
	}

	addr = atoi(argv[2]);
	printf("markbad 0x%08x...\n", addr);
	if (addr >= gxflash_get_info(GX_FLASH_CHIP_SIZE)) {
		printf("mardbad address is over the flash size\n");
		return;
	}
	if (gxflash_write_protect_unlock()) {
		printf("unlock error in file: %s func: %s line: %d\n",__FILE__, __func__, __LINE__);
		return;
	}
	gxflash_block_markbad(addr);
	printf("done\n");
}

SUBCOMMAND(flash, badinfo, flash_badinfo, "-- Print a list of all of the bad blocks in the current flash", 0);
void flash_badinfo(int argc, const char **argv)
{
#define NAND_BLOCK_SIZE (128*1024)
	unsigned int addr;
	unsigned int len;

	len = gxflash_get_info(GX_FLASH_CHIP_SIZE);

	for (addr = 0; addr < len; addr += NAND_BLOCK_SIZE)
	{
		if (gxflash_block_isbad(addr))
			printf("addr : 0x%08x  block num : %d is bad\n", addr, addr / NAND_BLOCK_SIZE);
	}

	printf("done\n");
}
#endif

#ifdef CONFIG_ENABLE_SFLASH
/**************************************** sflash otp **************************************************/
COMMAND(sflash_otp, otp_operation, "<lock|status|erase|setregion num|getregion> -- get the lock status or region or erase the sflash otp");
void otp_operation(int argc, const char **argv)
{
	unsigned int data;
	unsigned char status;
	char *cmd = NULL;

	if(argc < 2){
		printf("arg not enough, please read help.\n");
		return;
	}

	cmd = (char*)argv[1];

	if(strcmp("lock", cmd) == 0){
		gxflash_otp_lock();

	}else if(strcmp("status", cmd) == 0){
		gxflash_otp_status(&status);
		printf("otp status:%d\n", status);

	}else if(strcmp("erase", cmd) == 0){
		gxflash_otp_erase();

	}else if(strcmp("getregion", cmd) == 0){
		gxflash_otp_get_region(&data);
		printf("otp region:%d\n", data);

	}else if(strcmp("setregion", cmd) == 0){
		if(gxflash_otp_set_region(atoi(argv[2])) == 0)
			printf("otp region change => [%d] success\n", atoi(argv[2]));
		else
			printf("otp region change fail\n");

	}else{
		printf("arg error, please read help.\n");
	}
}

SUBCOMMAND(sflash_otp, read, otp_operation_read, "<otp address> <len> <file name>-- read data from sflash otp", 0);
void otp_operation_read(int argc, const char **argv)
{
	unsigned int len;
	unsigned int addr;
	unsigned char *buf = NULL;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}

	addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);
	if(buf == NULL)
		return;

	if(gxflash_otp_read(addr, buf, len) < 0)
		return;

	_uart_crc_data_w(buf, len);

	free(buf);
}

SUBCOMMAND(sflash_otp, write, otp_operation_write, "<otp address> <file name> -- use boot tool write sflash otp", 0);
void otp_operation_write(int argc, const char **argv)
{
	unsigned int i;
	unsigned int addr;
	unsigned int len;
	unsigned char *buf;

	if(argc < 4){
		printf("arg not enough, please read help.\n");
		return;
	}
	addr = atoi(argv[2]);
	len = atoi(argv[3]);

	buf = malloc(len);

	if (_uart_crc_data_r(buf, len)) {
		return ;
	}

	gxflash_otp_write(addr, buf, len);
	free(buf);
}

#endif

#if defined(CONFIG_ENABLE_NANDFLASH) || defined(CONFIG_ENABLE_SPINAND)

/*SUBCOMMAND(flash, scruberase, nand_scruberase, " -- chip scrub erase.", 0);
void nand_scruberase(int argc, const char **argv)
{
	extern void nandflash_scruberase(void);
	gxflash_write_protect_unlock();
	nandflash_scruberase();
}*/

SUBCOMMAND(flash, oobread, flash_oobread, "<flash addr> <memory addr> <length> -- read data from flash to memory", 0);
void flash_oobread(int argc, const char **argv)
{
	unsigned int ramaddr, flashaddr, len, j;

	if (argc < 5) {
		printf(FLASHW_MSG);
		return;
	}

	flashaddr = atoi(argv[2]);
	ramaddr = atoi(argv[3]);
	len = atoi(argv[4]);

	gxflash_readoob(flashaddr, (unsigned char *)ramaddr, len);
	for (j = 0; j < len; j++) {
		printf("%02x ", ((unsigned char *)ramaddr)[j]);
		if((j+1)%16 == 0)
			printf("\n");
	}

	printf("\n");
}

SUBCOMMAND(flash, oobwrite, flash_oobwrite, "<flash addr> <memory addr> <length> -- writes block of data into specified address", 0);
void flash_oobwrite(int argc, const char **argv)
{
	unsigned int to, from, len;

	if (argc < 5) {
		printf(FLASHW_MSG);
		return;
	}

	to = atoi(argv[2]);
	from = atoi(argv[3]);
	len = atoi(argv[4]);

	printf("Writing... ");
	gxflash_writeoob(to, (unsigned char *)from, len);
	printf("done\n");
}

#endif
#endif

/******************************************** DMA command ********************************************/
#if defined(CONFIG_ENABLE_AXI_DMA_TEST)
COMMAND(dma, command_dma, "<command> [args...] - dma operation");
void command_dma(int argc, const char **argv)
{
	if(argv[1] == NULL) {
		printf("dma config [src_trans_width] [dst_trans_width] [src_msize] [dst_msize] [src_addr_update] [dst_addr_update] [src_master_select] [dst_master_select]\n");
		printf("dma speed [src] [dst] [len] [channel] [count]\n");
		printf("dma m2m [src] [dst] [len] [mode] [channel] [printf]\n");
		printf("dma comtest\n");
		printf("dma multi_channel\n");
		printf("src/dst trans_width   0:8bit 1:16bit 2:32bit 3:64bit\n");
		printf("src/dst msize         0:1 items 1:4 items 2:8 items 3:16 items ... 9:1024items\n");
		printf("src/dst inc           0:addr inc 1:addr no inc\n");
		printf("src/dst master        0:axi maste1 1:axi master2\n");
		return ;
	}

	if (strcmp(argv[1], "config") == 0) {
		DW_DMAC_CH_CONFIG dma_config;
		if(argc >= 10) {
			dma_config.src_trans_width    = atoi(argv[2]);
			dma_config.dst_trans_width    = atoi(argv[3]);
			dma_config.src_msize          = atoi(argv[4]);
			dma_config.dst_msize          = atoi(argv[5]);
			dma_config.src_addr_update    = atoi(argv[6]);
			dma_config.dst_addr_update    = atoi(argv[7]);
			dma_config.src_master_select  = atoi(argv[8]); // master1 --> mem; master2 --> per
			dma_config.dst_master_select  = atoi(argv[9]); // master1 --> mem; master2 --> per
		}
		axi_do_dma_config(dma_config);
	}else if (strcmp(argv[1], "speed") == 0) {
		uint8_t *src = NULL;
		uint8_t *dst = NULL;
		int test_len = 0, test_count = 0;
		int channel = 0;

		if(argc >= 7) {
			src        = (uint8_t*)atoi(argv[2]);
			dst        = (uint8_t*)atoi(argv[3]);
			test_len   = atoi(argv[4]);
			channel    = atoi(argv[5]);
			test_count = atoi(argv[6]);
		}
		axi_do_memcpy_test(src, dst, test_len, channel, test_count);
	}else if (strcmp(argv[1], "m2m") == 0) {
		uint8_t *src = NULL;
		uint8_t *dst = NULL;
		uint32_t len, mode, channel, is_printf;
		if(argc >= 7) {
			src       = (uint8_t*)atoi(argv[2]);
			dst       = (uint8_t*)atoi(argv[3]);
			len       = atoi(argv[4]);
			mode      = atoi(argv[5]);
			channel   = atoi(argv[6]);
			is_printf = atoi(argv[7]);
		}
		axi_do_dma(src, dst, len, mode, channel, is_printf);
	}else if (strcmp(argv[1], "comtest") == 0) {
		axi_dma_comtest();
	}else if (strcmp(argv[1], "multi_channel") == 0) {
		axi_dma_multi_channel_test();
	}else
		printf("Unknown command\n");
}
#endif

/******************************************** Gen SPI command ********************************************/
#if defined(CONFIG_ENABLE_GEN_SPI_TEST)
COMMAND(spim_test, command_spim, "<command> [args...] - spi master operation");
void command_spim(int argc, const char **argv)
{
	if(argv[1] == NULL) {
		printf("spim_test read [len]\n");
		printf("spim_test write [data] [len]\n");
		printf("spim_test [format] [bits_per_word], format: 0: standard, 1: dual, 2:quad, 3: octal; bits_per_word: 8,16,32.\n");
		printf("spim_test case [bits_per_word] [count] [if_debug] bits_per_word:8/16/24/32 .\n");
		printf("spim_test write_read\n");
		return ;
	}

	spi_master_test_rw(argc, argv);
}

COMMAND(spis_test, command_spis, "<command> [args...] - spi slave operation");
void command_spis(int argc, const char **argv)
{
	if(argv[1] == NULL) {
		printf("spis_test read [len]\n");
		printf("spis_test write [data] [len]\n");
		printf("spis_test [format] [bits_per_word], format: 0: standard, 1: dual, 2:quad, 3: octal; bits_per_word: 8,16,32.\n");
		printf("spis_test case [bits_per_word] [count] [if_debug] bits_per_word:8/16/24/32 .\n");
		return ;
	}

	spi_slave_test_rw(argc, argv);
}
#endif

/******************************************** Network command ********************************************/
#ifdef CONFIG_ENABLE_NET
int network_up(int force)
{
	int state;

	if ((state = net_found()) == NETDEV_NODEV) {
		printf("Network device is not exist\n");
		return 1;
	} else if (state == NETDEV_UP && !force) {
		return 0;
	}

	if (g_bootconfig.protocol == BOOTNET_NONE) {
		printf("Configure network setting first\n");
		return 2;
	} else if (net_dev_up() == 0) {
		printf("Networking is enabled\n");
		return 0;
	} else {
		printf("Networking failure\n");
		return 3;
	}
}

COMMAND(net, command_net, "<command> [args...] - net operation");
void command_net(int argc, const char **argv)
{
	if (argc == 1) {
		return;
	}

	if (!net_found()) {
		printf("Network device is not exist\n");
		return;
	}

	if (strcmp(argv[1], "up") == 0) {
		network_up(1);
	} else if (strcmp(argv[1], "down") == 0) {
		net_dev_down();
		printf("Networking is disabled\n");

#if 0
	} else if (strcmp(argv[1], "bootp") == 0) {
		ipv4_bootp(1);
	} else if (strcmp(argv[1], "dhcp") == 0) {
		ipv4_bootp(0);
#endif
	} else if (strcmp(argv[1], "status") == 0) {
		net_device_status();
	}
#ifdef CONFIG_ENABLE_NETWORK_DNS
	else if (strcmp(argv[1], "dns") == 0) {
		if (argv[2] == NULL)
			printf("Specify host name\n");
		else {
			in_addr_t ipaddr;
			ipaddr = ipv4_gethostbyname(argv[2]);
			printf("IP address of %s is ", argv[2]);
			if (ipv4_ipaddr_valid(ipaddr))
				printf("%s\n", ipaddr_to_str(ipaddr));
			else
				printf("Invalid\n");
		}
	}
#endif
}

SUBCOMMAND(net, configip, net_configip, "<ipaddr> -- network stb ipaddr configuration", 0);
void net_configip(int argc, const char **argv)
{
	in_addr_t ipaddr;
	if(argc < 3)
	{
		printf("parameters not enough.\n");
		return;
	}
	if (parse_ipaddr((char *)argv[2], &ipaddr) == 0 )
		g_bootconfig.ipaddr = ipaddr;
}

SUBCOMMAND(net, configport, net_configport, "<tftpport> -- network tftpport configuration", 0);
void net_configport(int argc, const char **argv)
{
	if(argc < 3)
	{
		printf("parameters not enough.\n");
		return;
	}
	g_bootconfig.tftp_port = atoi(argv[2]);
}

SUBCOMMAND(net, configshow, net_configshow, "-- shows current network configuration", 0);
void net_configshow(int argc, const char **argv)
{
	int stat, valid;

	printf("Current network configuration\n");
	stat = net_found();
	printf("  Status : %s\n",
			(stat == NETDEV_NODEV) ? "No device" :
			((stat == NETDEV_DOWN) ? "Down" : "Up"));

	if (stat != NETDEV_NODEV) {
		valid = ipv4_ipaddr_valid(g_bootconfig.ipaddr);
		printf("  IP Address : %s\n",
				valid ? ipaddr_to_str(g_bootconfig.ipaddr) : "Not assigned");
		if (valid) {
			printf("  Netmask    : %s\n", ipaddr_to_str(g_bootconfig.netmask));
			printf("  Gateway    : %s\n", ipaddr_to_str(g_bootconfig.gateway));
			printf("  Server     : %s\n", ipaddr_to_str(g_bootconfig.server));
			printf("  DNS Server : %s\n", ipaddr_to_str(g_bootconfig.dns));
			printf("  Domain     : %s\n", g_bootconfig.domain);
			printf("  TFTP Port  : %d\n", g_bootconfig.tftp_port);
		}
	}
}

SUBCOMMAND(net, arp, net_arp, "<ip address>", 0);
void net_arp(int argc, const char **argv)
{
	in_addr_t ipaddr;

	if (network_up(0) != 0)
		;
	else if (argv[2] == NULL) {
		arp_listtable(NULL);
	} else {
		if (parse_ipaddr((char *)argv[2], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else {
			arptable_t *arp = arp_dorequest(ipaddr, 0);

			if (arp)
				arp_listtable(arp);
		}
	}
}

SUBCOMMAND(net, ping, net_ping, "<ip address>", 0);
void net_ping(int argc, const char **argv)
{
	in_addr_t ipaddr;

	if (network_up(0) != 0)
		;
	else if (argv[2] == NULL)
		printf("Specify IP address\n");
	else {
		if (parse_ipaddr((char *)argv[2], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else {
			if(icmp_ping(ipaddr, 1) <= 0)
				printf("network ping is error.\n");
			else
				printf("network ping is ok.\n");
		}
	}
}

SUBCOMMAND(net, tftp, net_tftp, "<ip address> <filename>", 0);
void net_tftp(int argc, const char **argv)
{
	in_addr_t ipaddr;
	char string_ip[20];

	if (network_up(0) != 0)
		;
	else if (argv[2] == NULL)
		printf("Specify IP address\n");
	else if (argv[3] == NULL)
		printf("Specify filename to download\n");
	else {
		memcpy(string_ip, argv[2], strlen(argv[2]) + 1);
		if (parse_ipaddr((char *)argv[2], &ipaddr) != 0 || !ipv4_ipaddr_valid(ipaddr))
			printf("Invalid IP address\n");
		else {
			unsigned int addr = DRAMBASE;
			unsigned int len;

			if ((ipv4_tftp(ipaddr, g_bootconfig.tftp_port, TFTPOP_RRQ, (char *)argv[3], addr, &len)) == 0) {
				printf("tftp finished, %s: 0x%x 0x%x\n", string_ip, len, addr);
			}
		}
	}
}

#endif

/******************************************** usb command ********************************************/
#ifdef CONFIG_ENABLE_USB
extern int au_usb_stor_curr_dev;

int usb_cmd_init(const char *filename, unsigned long *file_size)
{
	static block_dev_desc_t *stor_dev;
	int parts = 0;
	int i;
	int res = 0;
	unsigned long len = 0;
	int gpt_flag = 0;

	if (au_usb_stor_curr_dev == -1) {
		/* start USB */
		if (usb_stop() < 0) {
			printf("usb_stop failed\n");
			return -1;
		}
		if (usb_init() < 0) {
			printf("usb_init failed\n");
			return -1;
		}
		/*
		 * check whether a storage device is attached (assume that it's
		 * a USB memory stick, since nothing else should be attached).
		 */
		au_usb_stor_curr_dev = usb_stor_scan(0);
		if (au_usb_stor_curr_dev == -1) {
			printf("No device found. Not initialized?\n");
			res = -1;
			goto xit;
		}
		/* check whether it has a partition table */
		stor_dev = usb_stor_get_dev(0);
		if (stor_dev == NULL) {
			printf("uknown device type\n");
			res = -1;
			goto xit;
		}

		gpt_flag = print_part_efi(stor_dev);
		if (gpt_flag == 0) {
			printf("\nSearching GPT failed, Searching MBR...\n");
			parts = get_partitions_extended(stor_dev, 0, 0);
			printf("Find  %d parts\n", parts);
			print_part_dos(stor_dev);
		}
	}

	if (gpt_flag == 0) {
		for (i = 1; i <= USB_MAX_PARTITON; i++) {
			if (fat_register_device(stor_dev, i) != 0) {
				printf("Unable to use USB %d:%d for fatls\n",
						au_usb_stor_curr_dev, i);
				continue;
			}

			if (file_fat_detectfs() != 0) {
				printf("USB %d: %d file_fat_detectfs failed\n",
						au_usb_stor_curr_dev, i);
				continue;
			}

			if (filename != NULL) {
				file_get_size(filename, &len);
				if (len > 0) {
					*file_size = len;
					break;
				}
			} else
				break;
		}
	} else {
		for (i = 1; i <= USB_MAX_PARTITON; i++) {
			if (fat_register_device_efi(stor_dev, i) != 0) {
				printf("Unable to use USB %d:%d for fatls\n",
						au_usb_stor_curr_dev, i);
				continue;
			}

			if (file_fat_detectfs() != 0) {
				printf("USB %d: %d file_fat_detectfs failed\n",
						au_usb_stor_curr_dev, i);
				continue;
			}

			if (filename != NULL) {
				file_get_size(filename, &len);
				if (len > 0) {
					*file_size = len;
					break;
				}
			} else
				break;
		}
	}

	if (i == USB_MAX_PARTITON + 1) {
		printf("Error: Not Find, Find %d parts\n", parts);
	}
 xit:
	return res;
}

void usb_cmd_finish(void)
{
	if (usb_stop() < 0) {
		printf("usb_stop failed\n");
	}
	au_usb_stor_curr_dev = -1;
}

COMMAND(usbdown, command_usb, "<partition name|flash addr> <file name> [yaffs|wholebin] -- download according usb. ");
void command_usb(int argc, const char **argv)
{
	int ret = -1;
	char *pbuf = NULL;
	static char *dbuf = NULL;
	static int dtb_size = 0;
	unsigned long download_size = 0;
	if (argc < 3) {
		printf("error: parameters not enough.\n");
		return;
	}

	usb_cmd_init(argv[2], &download_size);

	if (strcmp(argv[3], "dtb") == 0) {
		dbuf = malloc(download_size);
		if (dbuf == NULL) {
			printf("error: malloc failed.\n");
			goto exit;
		}

		if ((ret = file_fat_read(argv[2], dbuf, download_size)) == -1) {
			printf("error: file fat read return -1, please check the file exists.\n");
			dtb_size = 0;
			goto exit;
		} else {
			dtb_size = download_size;
			printf("actually read file(%s) length 0x%x.\n", argv[2], download_size);
		}
		goto exit;
	}

	pbuf = malloc(download_size);
	if (pbuf == NULL) {
		printf("error: malloc failed.\n");
		goto exit;
	}

	if ((ret = file_fat_read(argv[2], pbuf, download_size)) == -1) {
		printf("error: file fat read return -1, please check the file exists.\n");
		goto exit;
	} else
		printf("actually read file(%s) length 0x%x.\n", argv[2], download_size);

	if (strcmp(argv[3], "wholebin") == 0 && flash_get_type() != 0)
		nand_whole_bin_download(pbuf);
	else if ((strcmp(argv[3], "yaffs") == 0) || (strcmp(argv[3], "yaffs2") == 0))
		flash_download(&argv[1], pbuf, download_size, 1);
#ifdef CONFIG_ENABLE_UBI
	else if (strcmp(argv[3], "ubi") == 0) {
		if (argc >= 5)
			ubi_download((char *)argv[1], (char *)argv[4], pbuf, download_size);
		else
			printf("error, ubi down need param volume name");
	}
#endif
	else if (dtb_size && (strcmp(argv[3], "kernel") == 0)) {
		char *all_buf = (char *)malloc(download_size + dtb_size);
		memcpy(all_buf, dbuf, dtb_size);
		memcpy(all_buf+dtb_size, pbuf, download_size);
		flash_download(&argv[1], all_buf, dtb_size+download_size, 0);
		printf("allsize : %d = 0x%x\n", dtb_size+download_size, dtb_size+download_size);
		if (all_buf)
			free(all_buf);
		if (dbuf)
			free(dbuf);
	} else
		flash_download(&argv[1], pbuf, download_size, 0);

exit:
	if(pbuf)
		free(pbuf);
	usb_cmd_finish();
	return;
}

COMMAND(usbdump, command_usbdump, "<partition name|flash addr> <file name> <dump size> -- dump according usb. ");
void command_usbdump(int argc, const char **argv)
{
	int ret = -1;
	char *buf = NULL;
	loff_t actwrite_size = 0;
	unsigned int len;
	unsigned long nousd;

	if (argc < 2) {
		printf("error: parameters not enough(%d).\n", argc);
		return;
	}

	len = atoi(argv[2]);

	buf = malloc(len);
	if (buf == NULL) {
		printf("error: malloc failed.\n");
		goto exit;
	}

#ifdef CONFIG_ENABLE_UBI
	if (argc >= 5 && strcmp(argv[4], "ubi") == 0) {
		if (argc >= 6)
			ubi_dump((char *)argv[1], (char *)argv[5], buf, len);
		else
			printf("error, ubi dump need param volume name");
	} else
		flash_dump(&argv[1], buf, len);
#else
	flash_dump(&argv[1], buf, len);
#endif

	usb_cmd_init(NULL, &nousd);

	if ((ret = file_fat_write(argv[3], buf, 0, (loff_t)len, &actwrite_size)) == -1) {
		printf("error: file fat write return -1,file(%s) len(%d) actwrite(%d).\n",argv[2], len, actwrite_size);
		goto exit;
	} else
		printf("actually write file(%s) length 0x%x.\n", argv[2], len);
exit:
	if(buf)
		free(buf);
	usb_cmd_finish();
	return;
}
#endif

#ifdef CONFIG_ENABLE_RCC
COMMAND(rcc, command_rcc, "<start_addr> <size> -- Protect the memory in order to avoid be modified. ");
void command_rcc(int argc, const char **argv)
{
	unsigned int start_addr, size;
	start_addr = atoi(argv[1]);
	size = atoi(argv[2]);
	rcc_mem_protect(start_addr, size);
}
#endif

#ifdef CONFIG_ENABLE_IRR
COMMAND(irr, command_irr, "<operate> -- operate \"run\" to wait irr key press");
void command_irr(int argc, const char **argv)
{
	unsigned int code = 0;
	unsigned int len = 4;

	if (strcmp(argv[1], "run")) {
		printf("ex. type 'irr run' to wait irr key press.\n");
		return;
	}

	printf("wait irr key press\n");

	while(1) {
		code = 0;
		len  = 4;
		irr_read(&code, &len);
		if (code != 0) {
			printf("key value : 0x%08x\n", code);
			break;
		}
	}
}
#endif

#ifdef CONFIG_ENABLE_TIME
COMMAND(time, command_time, "<get_us | get_ms > <delay ms> -- get system run time or test delay func");
void command_time(int argc, const char **argv)
{
	unsigned int delay_ms = 0;
	u32 start_time = 0;
	u32 end_time = 0;

	if (argc < 2) {
		printf("error: less argument\n");
		return;
	}

	if (!strcmp(argv[1], "delay") && argc < 3) {
		printf("error: less argument\n");
		return;
	} else {
		delay_ms = atoi(argv[2]);
	}

	gx_time_init();

	if (!strcmp(argv[1], "delay")) {
		start_time = gx_time_get_ms();
		gx_time_delay_us(delay_ms*1000);
		end_time = gx_time_get_ms();
		printf("start delay time : %d ms\n", start_time);
		printf("end delay time : %d ms\n", end_time);
	} else if (!strcmp(argv[1], "get_us")) {
		printf("system run time : %d us\n", (u32)gx_time_get_us());
	} else if (!strcmp(argv[1], "get_ms")) {
		printf("system run time : %d ms\n", gx_time_get_ms());
	} else {
		printf("error: time command error parameters. please type \"time help\"\n");
	}
}
#endif

#ifdef CONFIG_ENABLE_I2C
COMMAND(i2cget, i2cget, "-y <bus id> <chip addr> <reg addr> [len] -r [reg_addr_width]");
void i2cget(int argc, const char **argv)
{
	unsigned int bus_id = 0;
	unsigned int chip_addr = 0;
	unsigned int reg_addr = 0;
	void *i2c_dev = NULL;
	unsigned char *data = NULL;
	int data_len = 1;
	int i = 0;
	unsigned int reg_addr_width = 1;

	if (argc < 5) {
		printf("error: less argument\n");
		return;
	}

	bus_id = atoi(argv[2]);
	chip_addr = atoi(argv[3]);
	reg_addr = atoi(argv[4]);

	if (argc >= 6)
		data_len = atoi(argv[5]);
	if (argc >= 8) {
		if (!strncmp(argv[6], "-r", strlen("-r")))
			reg_addr_width = atoi(argv[7]);
	}

	i2c_dev = gx_i2c_open(bus_id);
	if (i2c_dev == NULL) {
		printf("open i2c %d failed\n", bus_id);
		return;
	}

	if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
		printf("set i2c %d failed\n", bus_id);
		goto i2cget_exit;
	}

	data = malloc(data_len);
	if (data == NULL) {
		printf("i2c malloc receive data failed\n");
		goto i2cget_exit;
	}
	if (gx_i2c_rx(i2c_dev, reg_addr, data, data_len) != data_len) {
		printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
		goto i2cget_exit;
	}

	printf("data: ");
	for (i = 0; i < data_len; i++)
		printf("0x%02x ", data[i]);
	printf("\n");
i2cget_exit:
	if (data)
		free(data);
	gx_i2c_close(i2c_dev);
	return ;
}

COMMAND(i2cset, i2cset, "-y <bus id> <chip addr> <reg addr> <data> [data1] ... [datax] -r [reg_addr_width]");
void i2cset(int argc, const char **argv)
{
	unsigned int bus_id = 0;
	unsigned int chip_addr = 0;
	unsigned int reg_addr = 0;
	void *i2c_dev = NULL;
	unsigned char *data = NULL;
	int data_len = 0;
	int i = 0;
	unsigned int reg_addr_width = 1;

	if (argc < 6) {
		printf("error: less argument\n");
		return;
	}

	bus_id = atoi(argv[2]);
	chip_addr = atoi(argv[3]);
	reg_addr = atoi(argv[4]);

	if (argc >= 8) {
		for (i = 6; i < argc; i++) {
			if (!strncmp(argv[i], "-r", strlen("-r"))) {
				if (i + 1 < argc)
					reg_addr_width = atoi(argv[i+1]);
				break;
			}
		}
	} else
		i = argc;

	i2c_dev = gx_i2c_open(bus_id);
	if (i2c_dev == NULL) {
		printf("open i2c %d failed\n", bus_id);
		return;
	}

	if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
		printf("set i2c %d failed\n", bus_id);
		goto i2cset_exit;
	}

	data_len = i - 5;
	data = malloc(data_len);
	if (data == NULL) {
		printf("i2c malloc send data failed\n");
		goto i2cset_exit;
	}

	for (i = 0; i < data_len; i++)
		data[i] = atoi(argv[5 + i]);

	if (gx_i2c_tx(i2c_dev, reg_addr, data, data_len) != data_len) {
		printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
		goto i2cset_exit;
	}

i2cset_exit:
	if (data)
		free(data);
	gx_i2c_close(i2c_dev);
	return ;
}

COMMAND(i2c_auto_test, i2c_auto_test, "-y <bus_id> <test_times>");
void i2c_auto_test(int argc, const char **argv)
{
	unsigned int bus_id = 0;
	unsigned int chip_addr = 0;
	unsigned int reg_addr = 0;
	void *i2c_dev = NULL;
	unsigned char tx_data[128] = {0};
	unsigned char rx_data[128] = {0};
	int data_len = 0;
	int i = 0;
	unsigned int reg_addr_width = 1;
	unsigned int test_times = 1;
	unsigned int cnt = 0;

	if (argc < 4) {
		printf("error: less argument\n");
		return;
	}

	bus_id = atoi(argv[2]);
	i2c_dev = gx_i2c_open(bus_id);
	if (i2c_dev == NULL) {
		printf("open i2c %d failed\n", bus_id);
		return;
	}

	test_times = ((test_times = atoi(argv[3])) ? test_times : 1);

	while (test_times--) {
		mdelay(100);
		cnt++;
		printf("test cnt : %d\n", cnt);

		/* GX1133 */
		printf("start test GX1133\n");
		chip_addr = 0x5a;
		reg_addr_width = 2;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		reg_addr = 0xfff4;
		tx_data[0] = 0x33;
		data_len = 1;
		if (gx_i2c_tx(i2c_dev, reg_addr, tx_data, data_len) != data_len) {
			printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		for (i = 0; i < data_len; i++) {
			if (rx_data[i] != tx_data[i]) {
				printf("error rx_data != tx_data\n");
				goto i2c_auto_test_exit;
			}
		}
		printf("test GX1133 successfully\n");

		/* RDA5815M */
		printf("start test RDA5815M\n");
		chip_addr = 0x0c;
		reg_addr_width = 1;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		reg_addr = 0x00;
		data_len = 2;
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		if (rx_data[0] != 0x58 || rx_data[1] != 0xf8) {
			printf("read rda5815m ID error\n");
			goto i2c_auto_test_exit;
		}
		reg_addr = 0x0b;
		data_len = 1;
		tx_data[0] = 0x33;
		if (gx_i2c_tx(i2c_dev, reg_addr, tx_data, data_len) != data_len) {
			printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		for (i = 0; i < data_len; i++) {
			if (rx_data[i] != tx_data[i]) {
				printf("error rx_data != tx_data\n");
				goto i2c_auto_test_exit;
			}
		}
		printf("test RDA5815M successfully\n");

		/* MXL608 */
		printf("start test MXL608\n");
		chip_addr = 0x60;
		reg_addr_width = 1;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		reg_addr = 0x0a;
		tx_data[0] = 0x33;
		data_len = 1;
		if (gx_i2c_tx(i2c_dev, reg_addr, tx_data, data_len) != data_len) {
			printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		reg_addr_width = 2;
		reg_addr = 0xfb0a;
		data_len = 1;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		for (i = 0; i < data_len; i++) {
			if (rx_data[i] != tx_data[i]) {
				printf("error rx_data != tx_data\n");
				goto i2c_auto_test_exit;
			}
		}
		printf("test MXL608 successfully\n");

#ifdef CONFIG_I2C_TYPE_DW /* GX I2C don't support clock stretch, DW I2C support clock stretch */
		/* GRUS */
		printf("start test GRUS\n");
		chip_addr = 0x18;
		reg_addr_width = 1;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		reg_addr = 0x00;
		tx_data[0] = 0x33;
		data_len = 1;
		if (gx_i2c_tx(i2c_dev, reg_addr, tx_data, data_len) != data_len) {
			printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		for (i = 0; i < data_len; i++) {
			if (rx_data[i] != tx_data[i]) {
				printf("error rx_data != tx_data\n");
				goto i2c_auto_test_exit;
			}
		}
		printf("test GRUS successfully\n");
#endif

		/* EEPROM M24C32 */
		printf("start test EEPROM M24C32\n");
		chip_addr = 0x50;
		reg_addr_width = 2;
		if (gx_i2c_set(i2c_dev, bus_id, chip_addr << 1, reg_addr_width, 1, 0) != 0) {
			printf("set i2c %d failed\n", bus_id);
			goto i2c_auto_test_exit;
		}
		reg_addr = 0x00;
		tx_data[0] = 0x33;
		data_len = 1;
		if (gx_i2c_tx(i2c_dev, reg_addr, tx_data, data_len) != data_len) {
			printf("write i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		mdelay(10);
		if (gx_i2c_rx(i2c_dev, reg_addr, rx_data, data_len) != data_len) {
			printf("read i2c chip_addr 0x%02x reg 0x%02x failed\n", chip_addr, reg_addr);
			goto i2c_auto_test_exit;
		}
		for (i = 0; i < data_len; i++) {
			if (rx_data[i] != tx_data[i]) {
				printf("error rx_data != tx_data\n");
				goto i2c_auto_test_exit;
			}
		}
		printf("test EEPROM M24C32 successfully\n");
	}

	printf("finish i2c test\n");

i2c_auto_test_exit:
	gx_i2c_close(i2c_dev);
	return ;
}
#endif

//#define CONFIG_UART_TEST
#ifdef CONFIG_UART_TEST
static int baud[] = {9600, 57600, 115200, 230400, 460800, 500000, 576000, 921600, 1000000, 1152000, 1500000};
static int uart_do_baudrate_test(int port, int baudrate)
{
	char *test_str="i can speak english\r\n";

	printf ("Test Baudrate : %d, Press Enter to start\n", baudrate);
	uart_getc(CONFIG_UART_PORT);

	printf("starting testing... Press 'c' to cancel\n");
	uart_init(baudrate, port);
	while (1) {
		char c = 0;
		uart_putstring(port, (unsigned char *)test_str, strlen(test_str));
		mdelay(1000);
		uart_try_getc(&c, CONFIG_UART_PORT);
		if (c == 'c')
			break;
	}

	uart_init(115200, port);
	return 0;
}

void serial_stability_test(int port, int baudrate)
{
#define MAX_STRING_LENGTH 200
	uint8_t string[MAX_STRING_LENGTH + 1] = {0};
	int cnt = 0;
	int old_cnt = 0;
	uint8_t state = 0, ch;
	uint8_t uart_state = 0;

	uart_init(baudrate, port);
	while (1) {
		ch = uart_getc(port);

		switch (ch) {
			case '\n':
				string[cnt++] = ch;
				if (strncmp("query", string, 5) == 0) {
					uart_state = 0;
				} else {
					uart_putstring(port, string, cnt);
				}
				old_cnt = cnt;
				cnt = 0;
				break;
			default:
				if (cnt < MAX_STRING_LENGTH)
					string[cnt++] = ch;
				else
					cnt = 0;
		}
	}
	return;
}

static void uart_test_help(void)
{
	printf("uarttest <port> baudrate <9600|57600|115200|230400|460800|500000|576000|921600|1152000|1500000>\n");
	//printf("uarttest <port> tx_fifo_size\n");
	printf("uarttest <port> rx_fifo_size\n");
	printf("uarttest <port> flow_cts\n");
	printf("uarttest <port> flow_rts\n");
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
COMMAND(uarttest, uarttest, "<command> [args...] - uart test");
void uarttest(int argc, const char **argv)
{
	int i;
	char *cmd = NULL;
	char *endp;
	int port;
	int baudrate;

	if (argc < 3) {
		printf("error: less argument\n");
		uart_test_help();
		return;
	}

	port = simple_strtoull(argv[1], &endp, 10);
	if (*argv[1] == 0 || *endp != 0) {
		printf ("invalid args - port\n");
		return;
	}
	cmd = (char *)argv[2];

	if (0 == strcmp("baudrate", cmd)) {
		if (argc < 4) {
			printf("error: less argument\n");
			uart_test_help();
			return;
		}
		int baudrate = atoi(argv[3]);
		for (i = 0; i < ARRAY_SIZE(baud); i++) {
			if (baudrate == baud[i])
				break;
		}
		if (i == ARRAY_SIZE(baud)) {
			printf("don't support baudrate %d\n", baudrate);
			return;
		}
		uart_do_baudrate_test(port, baudrate);
	} else if (0 == strcmp("tx_fifo_size", cmd)) {
#if 0
		int fifo_size = 0;
		volatile int j = 1;
		printf("Start testing tx_fifo_size\n");
		uart_halt_tx(port, 1);
		while (1) {
			uart_putc('t', port);
			if (uart_get_tx_fifo_size(port) > fifo_size)
				fifo_size = uart_get_tx_fifo_size(port);
			else
				break;
		}
		uart_halt_tx(port, 0);
		printf("tx_fifo_size : %d\n", fifo_size);
#endif
	} else if (0 == strcmp("rx_fifo_size", cmd)) {
		printf("Start testing rx_fifo_size, Please input more data to fill fifo\n");
		while (1) {
			printf("rx_fifo_size : %d\n", uart_get_rx_fifo_size(port));
		}
	} else if (0 == strcmp("flow_cts", cmd)) {
		i = 0;

		uart_enable_auto_flow(port, 1);
		while (1) {
			if (i % 16)
				uart_compatible_putc('\n', port);
			uart_putc('A', port);
			i++;
		}
	} else if (0 == strcmp("flow_rts", cmd)) {
		uart_enable_auto_flow(port, 1);
		while (1) {
			for (i = 0; i < 128; i++) {
				uart_getc(port);
				mdelay(2000);
			}
		}
	} else if (0 == strcmp("stability", cmd)) {
		if (argc < 4) {
			printf("error: less argument\n");
			uart_test_help();
			return;
		}
		int baudrate = atoi(argv[3]);
		for (i = 0; i < ARRAY_SIZE(baud); i++) {
			if (baudrate == baud[i])
				break;
		}
		if (i == ARRAY_SIZE(baud)) {
			printf("don't support baudrate %d\n", baudrate);
			return;
		}
		serial_stability_test(port, baudrate);

	} else {
		printf("error cmd");
	}
}

#ifdef CONFIG_UART_BRC
extern int gx_brc_start(int id, int timeout_ms, unsigned int *width);
extern int gx_brc_calculate_uart_freq(int width, int baud);
void uart_brc_test(int argc, const char **argv)
{
	char *endp;
	int port, ret;
	unsigned int width;
	unsigned int freq;

	if (argc < 2) {
		printf("uart_brc_test port\n");
		return;
	}

	port = simple_strtoull(argv[1], &endp, 10);

	ret = gx_brc_start(port, 1000, &width);
	if (ret == 0) {
		freq = gx_brc_calculate_uart_freq(width, 115200);
		printf("freq = %d\n", freq);
		return;
	}

	printf("uart_brc_test error\n");
	return;
}
COMMAND(uart_brc_test, uart_brc_test, "<command> [args...] - uart brc test");

#endif
#endif

/***************************************** GPIO ******************************************************/
//#define CONFIG_GPIO_TEST
#ifdef CONFIG_GPIO_TEST
COMMAND(gpio, gpio_test,"help\n"
			"gpio get_io gpio_port\n"
		        "gpio set_io gpio_port 1/0\n"
			"gpio set_level gpio_port 1/0\n"
			"gpio get_level gpio_port\n"
			"gpio all_gpio_output_test 1/0\n"
			"gpio all_gpio_input_test\n"
			"gpio disable_pwm gpio_port\n"
			"gpio set_pwm     gpio_port cycle_ns duty_ns\n"
			"gpio set_all_gpio_pwm cycle_ns duty_ns\n"
			"gpio request_all_gpio_irq mode     -- (EDGE_FALLING 1 EDGE_RISING 2 EDGE_BOTH 3 LEVEL_HIGHT 4 LEVEL_LOW 8 )\n"
			"gpio request_irq gpio_port mode     -- (EDGE_FALLING 1 EDGE_RISING 2 EDGE_BOTH 3 LEVEL_HIGHT 4 LEVEL_LOW 8 )\n"
			"gpio disable_irq gpio_port\n");

static int gpio_irq_callback(int gpio, void *pdata)
{
	printf("gpio %d interrupt\n", gpio);

	return 0;
}

static int all_gpio_pwm_test(unsigned int cycle_ns, unsigned int duty_ns)
{
extern struct gpio_entry_bootloader g_gpio_table[];
extern unsigned int get_gpio_entry_num(void);
	int i = 0;
	int entry_num = get_gpio_entry_num();

	for (i = 0; i < entry_num; i++) {
		gx_gpio_enable_pwm(g_gpio_table[i].vir_gpio, cycle_ns, duty_ns, PWM_POLARITY_NORMAL);
	}
}
static int all_gpio_irq_test(int mode)
{
extern struct gpio_entry_bootloader g_gpio_table[];
extern unsigned int get_gpio_entry_num(void);
	int i = 0;
	int entry_num = get_gpio_entry_num();

	for (i = 0; i < entry_num; i++) {
		gx_gpio_enable_trigger(g_gpio_table[i].vir_gpio, mode, gpio_irq_callback, NULL);
	}
}

static int all_gpio_output_test(int level)
{
extern struct gpio_entry_bootloader g_gpio_table[];
extern unsigned int get_gpio_entry_num(void);
	int i = 0;
	int entry_num = get_gpio_entry_num();

	for (i = 0; i < entry_num; i++) {
		gx_gpio_setio(g_gpio_table[i].vir_gpio, 1);
	}

	for (i = 0; i < entry_num; i++) {
		gx_gpio_setlevel(g_gpio_table[i].vir_gpio, level);
	}
}

static int all_gpio_input_test(void)
{
extern struct gpio_entry_bootloader g_gpio_table[];
extern unsigned int get_gpio_entry_num(void);
	int i = 0;
	int entry_num = get_gpio_entry_num();

	for (i = 0; i < entry_num; i++) {
		gx_gpio_setio(g_gpio_table[i].vir_gpio, 0);
	}

	for (i = 0; i < entry_num; i++) {
		printf("gpio %d level %d\n", g_gpio_table[i].vir_gpio, gx_gpio_getlevel(g_gpio_table[i].vir_gpio));
	}
}

void gpio_test(int argc, const char **argv)
{
	int ret, v_gpio;
	int least_argc = 3;

	if (!strcmp(argv[1], "all_gpio_input_test")) {
		least_argc = 2;
	}
	if (argc < least_argc) {
		printf("error: less argument !\n");
		return;
	}
	v_gpio = atoi(argv[2]);

	if (!strcmp(argv[1], "set_io")) {
		int value;
		if (argc < 4) {
			printf("error: less argument !\n");
			return;
		}
		value  = atoi(argv[3]);
		ret = gx_gpio_setio(v_gpio, value);
		if (ret < 0) {
			printf("error: set io v_gpio '%d' failed !\n", v_gpio);
			return;
		}
		printf("worning: set v_gpio '%d' mode '%s'\n", v_gpio, value?"output":"input");
	} else if (!strcmp(argv[1], "get_io")) {
		ret = gx_gpio_getio(v_gpio);
		if (ret < 0) {
			printf("error: set io v_gpio '%d' failed !\n", v_gpio);
			return;
		}
		printf("v_gpio '%d' mode '%s'\n", v_gpio, ret?"output":"input");
	} else if (!strcmp(argv[1], "set_level")) {
		int value;
		if (argc < 4) {
			printf("error: less argument !\n");
			return;
		}
		value  = atoi(argv[3]);
		ret = gx_gpio_setlevel(v_gpio, value);
		if (ret < 0) {
			printf("error: set value v_gpio '%d' failed !\n", v_gpio);
			return;
		}
		printf("operate sucess !\n");
	} else if (!strcmp(argv[1], "get_level")) {
		ret = gx_gpio_getlevel(v_gpio);
		if (ret < 0) {
			printf("error: get v_gpio '%d' failed !\n", v_gpio);
			return;
		}
		printf("v_gpio: %d, value: %d\n", v_gpio, ret);
	} else if (!strcmp(argv[1], "all_gpio_output_test")) {
		int value;
		if (argc < 3) {
			printf("error: less argument !\n");
			return;
		}
		value  = atoi(argv[2]);
		all_gpio_output_test(value);
	} else if (!strcmp(argv[1], "all_gpio_input_test")) {
		int value;
		if (argc < 2) {
			printf("error: less argument !\n");
			return;
		}
		value  = atoi(argv[2]);
		all_gpio_input_test();
	} else if (!strcmp(argv[1], "set_pwm")) {
		int cycle_ns, duty_ns;
		if (argc < 5) {
			printf("error: less argument !\n");
			return;
		}
		cycle_ns = atoi(argv[3]);
		duty_ns = atoi(argv[4]);
		if (gx_gpio_enable_pwm(v_gpio, cycle_ns, duty_ns, PWM_POLARITY_NORMAL) < 0) {
			printf("set v_gpio '%d' pwm failed\n", v_gpio);
			return;
		}
	} else if (!strcmp(argv[1], "disable_pwm")) {
		if (gx_gpio_disable_pwm(v_gpio) < 0) {
			printf("disable v_gpio '%d' pwm failed\n", v_gpio);
			return;
		}
	} else if (!strcmp(argv[1], "set_all_gpio_pwm")) {
		int cycle_ns, duty_ns;
		if (argc < 4) {
			printf("error: less argument !\n");
			return;
		}
		cycle_ns = atoi(argv[2]);
		duty_ns = atoi(argv[3]);
		all_gpio_pwm_test(cycle_ns, duty_ns);
	} else if (!strcmp(argv[1], "request_irq")) {
		int mode;

		if (argc < 4) {
			printf("error: less argument !\n");
			return;
		}
		mode = atoi(argv[3]);
		if (gx_gpio_enable_trigger(v_gpio, mode, gpio_irq_callback, NULL) < 0) {
			printf("enable v_gpio '%d' trigger failed\n", v_gpio);
			return;
		}
	} else if (!strcmp(argv[1], "disable_irq")) {
		if (gx_gpio_disable_trigger(v_gpio) < 0) {
			printf("diable v_gpio '%d' trigger failed\n", v_gpio);
			return;
		}
	} else if (!strcmp(argv[1], "request_all_gpio_irq")) {
		int mode;

		if (argc < 3) {
			printf("error: less argument !\n");
			return;
		}
		mode = atoi(argv[2]);
		all_gpio_irq_test(mode);
	} else
		printf("error: error argument !\n");
}
#endif
