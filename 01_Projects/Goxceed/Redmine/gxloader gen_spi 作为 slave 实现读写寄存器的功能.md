
# 数据包格式
```
字节位置   字段名称    说明                值范围
Byte 0     CMD        命令字节            0x20(读), 0xA0(写)
Byte 1     RESERVED   保留字节            固定为 0x00
Byte 2     ADDR[31:24] 地址高字节         0x00-0xFF
Byte 3     ADDR[23:16] 地址次高字节       0x00-0xFF  
Byte 4     ADDR[15:8]  地址次低字节       0x00-0xFF
Byte 5     ADDR[7:0]   地址低字节         0x00-0xFF
Byte 6     DATA[31:24] 数据高字节         0x00-0xFF
Byte 7     DATA[23:16] 数据次高字节       0x00-0xFF
Byte 8     DATA[15:8]  数据次低字节       0x00-0xFF
Byte 9     DATA[7:0]   数据低字节         0x00-0xFF
Byte 10-13 RESERVED   保留字节            固定为 0x00
```

- spi 配置：
	- 单线

# 读
- 读 14 个字节数据，读完之后进行处理
- 解析第 0 个字节，判断是读还是写
- 解析第 2、3、4、5 个字节，作为地址 (大端)


# 写
- 读 14 个字节数据，读完之后进行处理
- 解析第 0 个字节，判断是读还是写
- 解析第 2、3、4、5 个字节，作为地址 (大端)
- 将第 6、7、8、9 字节的数据写到地址处 (大端)
- 最后四个字节不用管



# tx_and_rx 模式
- 配置：
	- cr0：tx_and_rx、8bit
	- 看下 clk 会不会配
	- txftlr：0
	- rxftlr：0
	- ctrlr1：rx_len
	- 看下 ser 会不会配
	- enr
- 传输：
	- 往 txfifo 写数据，等 txfifo 变为 empty，等 busy
	- 从 txfifo 读数据
- 数据写到 fifo 了，但是发不出去，使用 rx_only 模式可以发出去，ro 模式可以正常收到数据
	- 在启动 master 之前，需要先把要发送的数据填到 tx fifo，这样 master 时钟来的时候就会把数据 tx fifo 中的数据取走发出去

# 问题

## 切换成 virgo，不能正常收发数据
- 需要开关一下工具的 spi，否则有时候不能正常收数据
- 有时候收数据会漏掉，需要 master 发几次，才能收到数据
	- 因为相位没配好，1MHz 对应的相位是 6
	- 好像依旧很多次读到命令、dummy 错误，看看相位

- 首先确保一件事情：能够完整的收到数据包
	- 切换成**短线**之后可以正常的传输了
	- SPI 频率 1MHz (其实没关系，因为 master 提供时钟)，相位是 1

- 计算延时时间：
	- 100ms rtc 32768 分频，tick 从 0xe18 跳到了 0xfe4 = 460
	- 那么 tick 的单位是：200 us 左右
	- 148.5MHz 的 RTC 时钟，tick 走 32768 次大约是 `6.734ns * 32768 = 220us`
	- 这个时间有点久了，上位机的间隙大约是 70us 左右，所以这里最好是做成 10us
		- 预分频 1485 ，则 tick 走的时间约为：`6.734ns * 1485 = 10us`
		- 实际测试：拿第一个 tick，延时 100ms，再拿一个 tick，两个 tick 之间差值为 10151
		- 时间刚好就是 10us * 10151 大约是 100ms
- tick 计算方式：
	- 目前计算方式：一开始就拿到 tick，然后开始取数据，取每个数据的时候都会获取 tick，如果这个 tick 比 tick 晚了 100us，就认为超时了
	- 但是这里还有取数据的时间，所以这里的 tick 应该是从开始取数据，到所有数据也就是 8 个字节或者 4 个字节取完之后，再加上可能的空闲时间，才认为超时
	- 首先不加上空闲时间，只是 8 个字节：
		- 在 400K 的频率下，就是 137us，超时时间配成 160us
	- 修改计算方法：
		- 从开始拿数据开始，取 tick，然后将 tick 保存起来
		- 每次来数据都取 tick，如果此时的 tick 相比于上一次的 tick，超过了 N us，就认为超时了
- 为何延时时间设定为 120us：
![[Pasted image 20250628134818.png]]
- 考虑到上一个 clk 和下一个 clk 之间可能 107us，这里是超时时间，那么就配置的是如果一个包的空闲时间，都没有收到数据，就认为是错误的包
- 所以，这里的超时时间设置的是两个包之间的空闲时间