# AArch64 平台 GDB 汇编调试实践

本文档记录了一次在 AArch64 架构、Arm Cortex-A55 平台上使用 GDB 调试汇编代码的过程，旨在解决程序运行中出现的异常问题。

## 1. 背景：异常追踪

在运行目标程序时，通过 GDB 观察到程序进入了异常状态。初步检查发现，部分寄存器的值异常过大，疑似引发了该异常。为了定位问题的根源，需要深入到汇编层面进行调试。

## 2. 核心 GDB 调试指令与寄存器查看

AArch64 架构拥有 31 个 64位通用寄存器（`x0` 到 `x30`），以及一个零寄存器 (`xzr` 或 `x31` 在某些上下文中) 和栈指针 (`sp`)。每个通用寄存器的低32位可以通过 `w` 前缀访问（例如 `w0` 是 `x0` 的低32位）。

在本次汇编调试过程中，主要依赖以下 GDB 命令：

- **查看寄存器值**:
    
    - `p <expression>`: 打印表达式的值。在汇编调试中，常用于查看特定寄存器的当前值。
        
        - `p $x0`: 以默认格式（通常是十进制）打印寄存器 `x0` 的值。
            
        - `p/x $x0`: 以十六进制格式打印寄存器 `x0` 的值。
            
        - `p/t $x0`: 以二进制格式打印寄存器 `x0` 的值。
            
    - `i r <register_name_or_list>` (info registers): 显示一个或多个寄存器的值和状态。
        
        - `i r x0`: 显示寄存器 `x0` 的值。
            
        - `i r x0 x1 sp pc`: 显示 `x0`, `x1`, `sp` (栈指针), 和 `pc` (程序计数器) 的值。
            
        - `i r`: 显示所有通用寄存器的值。
            
    - **查看 `w` 寄存器**: GDB 通常不直接提供 `p $w0` 这样的命令。要查看 `w0` (即 `x0` 的低32位)，您可以查看 `x0` 的完整值，其低32位即为 `w0` 的内容。例如，执行 `p/x $x0` 后，结果中的后8个十六进制数字就代表了 `w0`。
        
- `display <expression>`: 设置一个表达式，在每次程序暂停时自动显示其值。
    
    - `display /i $pc`: 这是一个非常实用的组合，它会在每次单步执行或遇到断点时，自动反汇编并显示程序计数器（PC）所指向的当前指令。
        
    - `display /x $x1`: 每次暂停时以十六进制显示 `x1` 寄存器的值。
        
- `si` (Step Instruction): 单步执行一条机器指令。如果遇到函数调用，`si` 会进入函数内部。
    
- `x/<n_format_unit> <address>`: 检查内存地址。
    
    - `x/20i $pc`: 从程序计数器（PC）当前指向的地址开始，反汇编并显示接下来的 20 条指令。这有助于了解即将执行的指令序列。
        
    - `x/xg $sp`: 以十六进制格式显示栈指针 `sp` 指向的64位数据。
        

## 3. 调试准备

在开始调试前，需要进行以下准备工作：

1. **加载可执行文件**: 使用 GDB 加载包含调试信息的 `.elf` 文件。
    
    ```
    gdb loader.elf
    ```
    
2. **反汇编目标文件**: 为了便于对照和理解汇编代码，需要将 `.elf` 文件反汇编。
    
    ```
    aarch64-none-linux-gnu-objdump -S loader.elf > loader.dump
    ```
    
    将反汇编输出保存到 `loader.dump` 文件中，可以在调试时参考。
    

## 4. 详细调试步骤

1. 设置断点:
    
    在 GDB 中，根据代码逻辑或已知的可疑位置设置断点，使程序在关键点暂停。
    
    ```
    (gdb) b main
    (gdb) b *0x<address> // 或者直接在地址上打断点
    ```
    
2. 运行程序并监控 PC:
    
    运行程序直到遇到断点。为了实时追踪指令执行流程，设置 display /i $pc 命令：
    
    ```
    (gdb) run
    (gdb) display /i $pc
    ```
    
    此后，每次程序暂停（例如单步执行后），GDB 都会显示当前 PC 指向的汇编指令。
    
3. 检查当前指令上下文:
    
    当程序在断点处暂停或单步执行后，使用 x/20i $pc (或者其他合适的数目，如 x/10i $pc) 查看当前 PC 指向的指令以及后续的指令序列。
    
    ```
    (gdb) x/20i $pc
    ```
    
    这有助于理解程序即将执行的逻辑。
    
4. 单步调试与分析:
    
    使用 si 命令进行单步指令级调试。每执行一步：
    
    - 观察 `display /i $pc` 的输出，了解当前执行的指令。
        
    - 对照 `loader.dump` 文件中的反汇编代码，理解指令的含义和作用。
        
    - 使用 `p/x $<register_name>` (例如 `p/x $x0`, `p/x $sp`) 或 `i r <register_name>` 检查相关寄存器的值，判断其是否符合预期。
        
    - 特别关注导致程序流程改变的指令（如跳转、函数调用）以及对内存或关键寄存器进行操作的指令。
        
5. 定位问题:
    
    通过上述单步调试和寄存器状态检查，逐步缩小问题范围，直到找到导致寄存器值异常并引发异常的那条或那几条汇编指令。
    

## 5. 总结

通过结合使用 GDB 的 `display /i $pc`、`x/Ni $pc`、`si`、`p` 和 `info registers` 命令，并对照 `objdump` 生成的反汇编文件，可以有效地在 AArch64 平台上进行汇编级别的调试。这种方法对于定位底层代码错误、理解程序在特定硬件平台上的行为至关重要，尤其是在处理由寄存器异常值等问题引发的程序异常时。