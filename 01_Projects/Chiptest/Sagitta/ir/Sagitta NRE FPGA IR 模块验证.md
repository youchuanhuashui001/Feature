
# 红外协议
![[Pasted image 20250328150414.png]]

**红外接收头**

红外通信的一体化接收头 HS0038B，内部实现了信号的监测、放大、滤波、解调，直接输出的就是基带信号。当检测到有 38k 的红外信号时，就会在 OUT 引脚输出低电平；当没有 38K 的时候，OUT 引脚就会输出高电平。直接读 OUT 脚就可以获取红外信息。

**NEC 协议**
NEC 协议的数据格式包括了引导码、用户码、用户码（或者用户码反码）、按键键码和键码反码，最后一个停止位。停止位主要起隔离作用，一般不进行判断。
NEC 协议本身也会进行编码之后再发送：
- 引导码：9ms 的载波+4.5ms 的空闲
- 比特值“0”：560us 的载波+560us 的空闲
- 比特值“1”：560us 的载波+1.68ms 的空闲
- 停止码：560us 的载波
![[Pasted image 20250328150914.png]]
最前面是引导码 9ms 载波，接着是引导码的 4.5ms 空闲；后面的数据码根据传输的数据决定。

HS0038B 红外一体化接收头，当收到有载波的信号的时候，会输出一个低电平，空闲的时候会输出高电平。
![[Pasted image 20250328151042.png]]
- 最前面是 9ms 的载波，然后是 4.5ms 的空闲；数据码是低位在前，高位在后。
- 第一个字节是 8 组 560us 的载波+560us 的空闲，就是 8 个 0，0x00；
- 第二个字节是 8 组 560us 的载波加 1.68ms 的空闲，就是 8 个 1，0xff；
- 后面是发的命令 0x0c，接着是命令反码

还有一个重复码：产生 9ms 载波+2.25ms 空闲，再跟一个停止位



# 涉及到的文件
```
drivers/hal/src/ir/gx_hal_ir.o
cmd/gx_ir_test.o
```


* 主要文件：
	- `gx_ir_test.c`  `gx_hal_ir.h`  `gx_hal_ir.c`
* 主要功能：
	- 发送和接收标准红外协议数据
	-  发送和接收自定义红外协议数据
	-  载波频率和占空比的控制
	-  模拟部分

# 功能熟悉
## 发送功能
### 标准红外协议


# 概述 ：
固定模式用于收发协议为标准的 9012、NEC、RC5、RC6，此应用场景下，由硬件完成解码，输出解码数据。
灵活模式用于非标准收发协议的应用场景，由于无法识别协议，硬件模块只能对接收波形进行采样并存于 fifo 中，解码必须由软件完成。
固定模式的接收/发射可通过寄存器 `std_rx_en/std_tx_en` 使能和关闭；灵活模式的接收/发射颗通过 `ud_rx_en/ud_tx_en` 使能和关闭；
固定模式和灵活模式的发射不可同时使能，只能选一个进行发射；固定模式和灵活模式的接收可以同时使能。 

## 调制解调
### 调制
模块通过寄存器 `div_num` 和 `duty_num` 控制计数器来产生调制载波，其中 `div_num` 用于配置载波频率，载波频率为 `irc_clk/(div_num+1)`，`duty_num` 用于配置载波占空比，例如需要 `1/3` 占空比的载波，则配置 `duty_num=(div_num+1)/3-1`。

### 解调
用 8MHz 的 `irc_clk` 模块时钟，每隔 32 个时钟周期对输入的接收信号 `irc_rxd(带载波)` 进行采样，并送入移位寄存器 `rx_buf` 中。只要移位寄存器中任一 bit 为 1，则解调输出 `1`；若移位寄存器所有 bit 都为 0，则解调输出 `0`。
移位寄存器位宽为 30bit，可通过寄存器 `demod_length` 配置 8 档解调窗口，长度范围为 `16~30bit`。
可解调最低载波率= `irc_clk频率/32/8/(16+2*demod_length)`
例如：采样时钟 irc_clk 为 8MHz，配置 demod_length=0 (窗口长度为 16)，则 `8MHz/32/16=15.5kHz`，此时解调模块可以处理的最低载波频率为 15.5kHz。
当配置 `demod_length=7(窗口长度为30)`，则此时可解调的最小载波频率为 `8Mhz/32/30=8.33kHz`。
![[Pasted image 20250331100710.png]]
若载波频率低于配置可解调的载波频率下限，即使对连续的载波进行采样，移位寄存器中仍会出现所有 bit 均为 0 的时刻，导致解调输出产生 glitch (小故障)。

## 消抖滤波器
由于采用数字实现解调，消抖滤波器主要用于消除解调模块可能产生的 glitch。采用 30bit 移位寄存器对解调输出信号每隔 32 个 irc_clk 进行采样和移位。
当移位寄存器所有位的和大于可编程门限 `deb_length`，则认为解调输出为 `1`。
若移位寄存器所有位的和小于等于可编程门限 `deb_length`，则认为解调输出为 `0`。

> [!note]
> - 消抖滤波可以设置一个门限，通过采样数据与门限进行比较，来滤除可能产生的杂波


## 固定模式

### 发射
![[Pasted image 20250331101700.png]]


#### repeat 机制
![[Pasted image 20250331102418.png]]
当某个键被按下超过设定时长没有释放，寄存器 `rp_tx_en` 将被置 1 (释放后清零)。每当案件触发一次发射进程，当状态机从发射跳转至 stop 时，模块会检查此时 `rp_tx_en` 的值，若 `rp_tx_en == 1` ，则会将将状态标志位 `repeat_flag 置 1` ，并进行重发的延时计数。当延时时长满足协议规定的重发间隔，则状态机跳转至 `START` 状态并发射一个重发包。
若在延时满足重发间隔之前按键就被释放，则 `rp_tx_en` 会被清零，状态机调回 `IDLE` 状态，等待下一次按键触发发射。

> [!note]
> - 按键被按下指定时长，没有释放时： `rp_tx_en --> 1`；释放后 `rp_tx_en --> 0`
> - 按键在发射过程中，先检查 `rp_tx_en`，`if rp_tx_en == 1; repeat_flag --> 1`，进行重发的延时计数。延时时长满足规定的重发间隔，就发射重发包。
> - 如果在延时时，没延时到指定时长，则 `rp_tx_en -->0`，状态机回到 `IDLE`。


#### 帧间间隔
帧间间隔 `interval_mode == 0`，帧间间隔与 apus 一致，触发一次发射后，如果松开按键，则上报 txdone，然后可以马上按键触发下一次发射。
帧间间隔 `interval_mode == 1`，帧间间隔可配：
- 用于配置发完完整一帧后需要延时的时间，此时间内不会触发按键发射操作。
- 假设完整的一帧是 108ms，`引导码 + custom code + data + stop` 等等一共为 67ms 左右，协议规定空闲电平时长为 41ms 左右，接着会继续发下一帧
- 假设配置帧间间隔为 40ms，则上面的空闲电平时长为 41+40ms，总共的一帧时长为：`引导码 + custom code + data +stop` 等等一共 67ms，加上协议规定的 41ms，加上配置的延时 40ms，总共为：`67+41+40=148ms`

### 接收
状态机包括：`IDLE、START、RX_CC、RX_CC2、RX_KDC、RX_KDC2、STOP`

#### 协议自识别
根据四种协议，可见每个协议的 `Start bit or Header` 的第一个高电平脉冲持续时间有明显的差异，设计是测量这一脉冲的宽度来区分四种不同的协议：
![[Pasted image 20250331103251.png]]
实际应用中，接收到的信号可能不完全理想，通过寄存器 `IRC_RX_THR` 来配置判决门限，提高容错。
在判决成功前对于模块而言通信协议是未知的，判决门限必须要保证四种协议之间不会误判，所以判决门限要根据目前支持协议中 startbit 最短的两个协议来选择，thr 极限值不能大于两个协议 startbit 长度差的一半，否则会误判。

目前的四种协议9012/NEC/RC5/RC6中，startbit宽度最接近的是RC5 (0.844ms）和RC6(2.6ms)，以irc_clk为8MHz为例，RC5和RC6的Startupit的计数值分别为6751和21279，rx_thr_start 配置的理论极限值应为 `(21279-6751)/2 = 7264`。建议先把 `rx_thr_start` 配置为 `0x1388 = 5000` 看实测效果。

同理，9012/NEC模式下，对bit0（1.12ms）和bit1（2.25ms）的判决也可配置判决门限 rx_thr_data。以 irc_clk 为 8MHz 为例，bit0和 bit1 的计数值分别为 8960 和 18000，rx_thr_data 配置的理论极限值应为 (18000-8960)/2=4520。建议先把 rx_thr_data 配置为 0xBB8（十进制 3000）看实测效果。

> [!note] 
> - `rx_thr_start` 用于判决 start bit，主要判决 `rc5 or rc6`
> - `rx_thr_data` 用于判决 data，主要判决 `9012 or nec`

## 灵活模式
### 发射
把带发射数据填入 `tx fifo`，格式与 `rx fifo` 一致，其中高 16bit 为两次上升沿之间的计数值，低 16bit 为高电平的时长计数值。
配置 `tx_trig = ` 触发发射后，用 `irc_clk` 分频出 100kHz 时钟 **(具体分频比根据 CLK_DIV 寄存器来定)**，根据 txfifo 的内容构建原始数据。
```c
IRR_DATA = {0xaf005e, 0xaf005e, 0x10700b6, 0xaf005e, 0xaf005e, 0xaf005e, 0xaf005e, 0xaf005e, 0xaf005e, 0x107005d, 0x10700b6, 0xaf005e, 0xaf005e, 0xaf005e, 0xaf005e, 0xaf005e, 0x107005d, }
```
例如：`0xaf005e`，即当前传输逻辑位的高电平宽度为 0x5e 个 100kHz 的时钟周期，完整周期的高低电平总宽度为 0xaf 个 100kHz 时钟周期。
帧与帧之间的间隔符由全 1 表示，例如 fifo 位宽为 32 位，间隔符为 `0xffffffff`。当前芯片版本的 fifo 位宽，可以读寄存器 `IRC_FIFO_PARA` 获得。

> [!note]
> - 高 16bit 为两次上升沿之间的计数值，可以得到周期时长
> - 低 16bit 为高电平的时长计数值，可以得到占空比
> - 描述的是一个**逻辑位**的信息


### 接收
用 `irc_clk` 分频出 100kHz 时钟 (具体分配比根据 `CLK_DIV` 寄存器来定)，用 100kHz 时钟对**解调后数据**进行计数。
每个接收信号上升沿计数器清零，开始计数，下降沿记录高电平脉宽，下一次上升沿再记录完整周期的计数值，把完整周期计数值和高电平的计数值存入 `rx fifo`，然后计数器清零。
![[Pasted image 20250331105439.png]]
![[Pasted image 20250331105648.png]]
存入 rx fifo 的计数值，高 16bit 为两次上升沿之间的完整周期计数值，低 16bit 为高电平的计数值。
```c
IRR_DATA = {0xaf005e, ...}
```
例如：0xaf005e，即当前传输逻辑位的高电平宽度为 0x5e 个 100kHz 时钟周期，完整周期的高低电平总宽度为 0xaf 个 100kHz 时钟周期。
当计数值大于 rxtov，则认为该帧结束，产生 `rxtov、ud_rxdone` 中断。
需软件基于存在 `rxfifo` 中的计数值来判断是否为帧与帧之间的时间间隔。

> [!note]
> - 上升沿清零，开始计数得到上升沿占了多少个 100kHz 的周期数
> - 继续计数，到下一个上升沿，这样就得到整个 bit 的总时长
> - 计数器清零，继续循环上面两步操作
> - 若低电平持续时长长于设定的阈值 `rx_tov` ，则认为完成接收，产生 `rx_done` 中断。
> - 产生了 `rx_done` 中断后，需要软件根据 `rxfifo` 中的数据判断是帧与帧之间的间隔，还是停止接收。


### fifo
发送和接收各有一个 fifo。
寄存器 `IRC_UDRX_FIFO` 固定为 32bit，其中高 16bit 为 `rx_bit_width`，低 16bit 为 `rx_high_width`。当 fifo 位宽与寄存器位宽不一致时，按位宽分为高半段和低半段，分别低位对齐。
例如 `rx fifo` 位宽为 12bit，则存于 `rx fifo` 中的高 12bit 为接收信号高电平+低电平的脉宽，放在 `IRC_RX_FIFO[27:16]`；低 12bit 为接收信号高电平的脉宽，放在 `IRC_RX_FIFO[11:0]`。`IRC_UDRX_FIFO` 中未映射到的 bit 读为 0.
![[Pasted image 20250331111212.png]]

### 载波频率检测
可配置选用 `4/8/16` 个载波周期进行计数，计数结束后锁存结果，在 `rxdone` 中断时一并读出 (不专门设立中断)，然后通过寄存器读出结果 `carr_freq`，真实载波频率需要软件换算：
-  `载波频率 = 红外模块工作时钟/carr_freq`
- 比如载波频率为 38k，红外工作时钟为 8Mhz，则读出来的 carr_freq 应为 211.





### 非标准红外协议
配置数据，然后调制成某种红外波形发出去？
此应用场景下，由于无法识别协议，硬件模块只能对接收波形进行采样并存在 fifo 中，解码必须由软件完成。

## 接收功能
### 标准红外协议
- startbit 的判决门限，模块 clock 一个周期为单位
- 接收数据的判决门限，仅对 9012 和 NEC 协议有效，误差容限，以模块 clock 一个周期为单位





### 非标准红外协议




# 测试用例

**引脚复用：**
- pinmux 中引脚 `P4_3` 的功能 1 为 `IR`，这里指的是什么？
- iomatrix 中 `114 = IR_RX、115 = IR_TX、116 = IR_EN`
- 设置频率为晶振时钟 24MHz，3 分频到 8MHz，使能 IRC
- iomartix 设置 `pin3 = 123、pin4 = 122、pin7 = 124`，都是来自 `iomatrix`，但是我们实际测试时只插上了一个发射管，这里的三个引脚怎么对应？


## 标准协议带载波发送        
**测试命令：**
- `gx_ir send_std 1`
- 用 apus 来接收，判断发送是否正常
**示波器抓到的红外管短脚上的波形：**
![[0f16dd0f3700cb876ec263da5b044426.jpg]]
- 有波形的都是 38k 的载波，并且高电平占空比为 70%，低电平占空比为 30%
- 协议类型为 NEC，最前面是 9ms 的引导头，接着是 4.5ms 的空闲电平，接着是 custom code 和 curstom decode，以及数据
	- custom code：`1010 0010 1100 0100 1001 0001 1110 0110`，对应的 16 进制码为：`0x23 45 67 89`，正好是代码中发送的第一个 data word
	- `1111 1111 0111 0111 0100 0100 1000 1000`，对应的 16 进制码为：`0xeeff1122`，正好是要发送的 `data[1]`
	- `1101 0100 1101 1000 1101 0010 1101 1100`，对应的 16 进制码为：`0x1b2b3b4b`，正好是要发送的 `data[2]`
	- `0010 0010 0000 1001 0100 0000 0011 1000`，对应的 16 进制码为：`0x90441c02`，正好是要发送的 `data[3]`
	- 注：custom code 等等都是低位在前，高位在后

**apus 接收：**
- 不需要配置引脚复用，打开 `gx_ir` 测试命令
- 使用跳线帽接上 `P4_3 - IR`
- sagitta 执行命令：`gx_ir send_std 1`
- apus 执行命令：`gx_ir recv_std`
- apus 板子上的接收头要和 sagitta 上的发射头距离很近，能够正常解析到数据和协议
```
Done(0),recv type: 9012 , data: 23456789
Done(0),recv type: 9012 , data: eeff1122
Done(0),recv type: 9012 , data: 1b2b3b4b
Done(0),recv type: 9012 , data: 90441c02
Done(0),recv type: NEC , data: 23456789
Done(0),recv type: NEC , data: eeff1122
Done(0),recv type: NEC , data: 1b2b3b4b
Done(0),recv type: NEC , data: 90441c02
Done(0),recv type: RC5 , data: 50009
Done(0),recv type: RC5 , data: 1f0022
Error(10000001),recv type: RC5 , data: 1f0022
Done(0),recv type: RC5 , data: 50009
Done(0),recv type: RC5 , data: 1f0022
Done(0),recv type: RC5 , data: b000b
Done(0),recv type: RC5 , data: 40002
Done(0),recv type: RC6 , data: 450089
Done(0),recv type: RC6 , data: ff0022
Done(0),recv type: RC6 , data: 2b004b
Done(0),recv type: RC6 , data: 440002
```


## 标准协议带载波发送repeat  
测试命令：
- `gx_ir send_repeat 1 1`
	- type：要发送的协议类型
	- enable：前面是否发一个字节的 data
- 用 apus 来接收，判断发送是否正常
示波器抓取波形：
![[微信图片_2025-03-29_135209_756.png]]
- 先发一个 data，然后会一直发 repeat 码 (repeat + stop)
- 数据是 `1010 0010 1100 0100 1001 0001 1110 0110` + stop，对应的 16 进制码为：`0x23 45 67 89`
- 接着的 repeat 码：是 9ms 载波 + 2.25ms 空闲电平 + 停止位 (560us 载波)
- 间隔大约 95ms 左右会继续发下一个 repeat 码，但是按键是会间隔 108ms 产生一个 repeat 码？

**apus 接收数据**
- apus 执行命令：`gx_ir recv_std`
```
Done(10),recv type: 9012 REPEAT, data: 23456789                                
Done(10),recv type: NEC REPEAT, data: 23456789

Done(10),recv type: RC5 REPEAT, data: 50009                                    
Done(10),recv type: RC6 REPEAT, data: 50009 
```



## 标准协议带载波接收
测试命令：
- `gx_ir recv_std`
- 打印当前接收到的数据，判断是否正确
- 用万能遥控器发送，这个比较标准；apus 也可以发送，但是可能不太标准
- 能够正确收到数据，与之前的测试数据对比一致
**示波器怎么抓取波形**：[[Sagitta NRE FPGA IR 模块验证#^48a1be]] 





## 标准协议带载波接收repeat  
测试命令：
- `gx_ir recv_std`
- 打印当前接收到的是否为 repeat 码，判断是否正确
- 用万能遥控器发送，这个比较标准
- 能够正确收到 repeat，与之前的测试数据对比一致
**示波器怎么抓取波形？**


## 自动识别接收的协议类型   
测试命令：
- `gx_ir recv_std`
- 打印当前接收到的数据协议，判断是否正确
- 万能遥控器使用不同的协议，按下按键，能够正确解析


## 发送载波频率及占空比       
测试命令：
- `gx_ir set_freq [freq] [duty]`
- `gx_ir send_std 1`
- 查看发送的数据是否为新配置的载波频率即占空比
示波器抓取波形：
![[微信图片_20250329141836.jpg]]
- `gx_ir set_freq 64000 50`
- `gx_ir send_std 1`
- 查看载波频率为 64k，占空比为 50%
- 使用 `gx_ir set_freq 64000 20`，实际测得高电平占空比为 80，低电平占空比为 20
- 占空比与配置的相反是因为过了红外管会反向


## 中断触发             
测试命令：
- `gx_ir recv_std_it`
	- 使用万能遥控器按下按键，能够打印接收到的数据和类型
- `gx_ir recv_ud_it`
	- 使用万能遥控器按下按键，能够打印接收到的数据和类型
- `gx_ir send_std_it`
	- todo：用 apus 接收看看
- `gx_ir send_ud_it`
	- todo：用 apus 接收看看
- `gx_ir send_ud_nomod_it`
	- todo：用 apus 接收看看
- 能够触发对应的中断服务函数


## 带载波自由模式发送   
[[Sagitta NRE FPGA IR 模块验证#^de395a]]
测试命令：
- `gx_ir send_ud`
- 发送自定义波形，参考 mnec 协议，发送数据为：
	- `0111 1001 1100 0000 1111 1100 1001 1100`
- 使用机顶盒 gx6605s 板子接收，能够被识别为 nec 协议，判断接收到的数据是否与发送的数据相同
- 解析的值为发送值取反且MSB，结果正常
```
nec.
key value : 0x863f0363
```
**代码修改：**
```diff
--- a/conf/gx6605s/6605s/debug.config
+++ b/conf/gx6605s/6605s/debug.config
@@ -71,7 +71,7 @@ ENABLE_COMPRESS_ZLIB = n
-ENABLE_IRQ = n
+ENABLE_IRQ = y
-ENABLE_IRR = n
+ENABLE_IRR = y

--- a/drivers/irr/gx_irr.c
+++ b/drivers/irr/gx_irr.c
@@ -94,6 +94,8 @@ static int irr_parse_nec(gx_irr_extra*  extra)
                }
        }
 
+       printf("nec.\n");
+
        return 0;
 }

```


* 修改协议波形满足 nec 要求，发送数据为： `0111 1001 1100 0000 1111 1100 1001 1100`
* apus 能够正确解析到发送的数据
```diff
--- a/cmd/gx_ir_test.c
+++ b/cmd/gx_ir_test.c
@@ -761,15 +761,15 @@ static int gx_ir_test_recv_ud_send_it(GX_HAL_IR *ir_dev)
 int gx_ir_test_send_ud(GX_HAL_IR *ir_dev)
 {
        GX_HAL_IR_TX_CFG_T tx;
-       uint32_t data[64] = {0x04b00320,0x00640032,0x00c80032,0x00c80032,0x00c80032, /* 0111 */
-                                       0x00c80032,0x00640032,0x00640032,0x00c80032, /* 1001 */
-                                       0x00c80032,0x00c80032,0x00640032,0x00640032, /* 1100 */
-                                       0x00640032,0x00640032,0x00640032,0x00640032, /* 0000 */
-                                       0x00c80032,0x00c80032,0x00c80032,0x00c80032, /* 1111 */
-                                       0x00c80032,0x00c80032,0x00640032,0x00640032, /* 1100 */
-                                       0x00c80032,0x00640032,0x00640032,0x00c80032, /* 1001 */
-                                       0x00c80032,0x00c80032,0x00640032,0x00640032, /* 1100 */
-                                       0x00c80032};
+       uint32_t data[64] = {0x05460384,0x00700038,0x00e10038,0x00e10038,0x00e10038, /* 0111 */
+                                       0x00e10038,0x00700038,0x00700038,0x00e10038, /* 1001 */
+                                       0x00e10038,0x00e10038,0x00700038,0x00700038, /* 1100 */
+                                       0x00700038,0x00700038,0x00700038,0x00700038, /* 0000 */
+                                       0x00e10038,0x00e10038,0x00e10038,0x00e10038, /* 1111 */
+                                       0x00e10038,0x00e10038,0x00700038,0x00700038, /* 1100 */
+                                       0x00e10038,0x00700038,0x00700038,0x00e10038, /* 1001 */
+                                       0x00e10038,0x00e10038,0x00700038,0x00700038, /* 1100 */
+                                       0x00e10038};

```



## 带载波自由模式接收      
测试命令：
- `gx_ir recv_ud`
- 使用万能遥控器按下按键，能够打印接收到的数据



## 不带载波标准协议发送    
测试命令：
- `gx_ir send_std_nomod 1`
- 由于不带载波的情况很少，所以这里简单测试了一下
- 量从 fpga 过来的引脚波形，不要过红外管，因为红外管只处理带载波的情况
示波器抓取波形：
![[微信图片_20250329144658.jpg]]
- **没有载波，纯粹的高低电平**
- 9ms 的低电平，4.5ms 的高电平；
- 560us 的低电平，1.68ms 的高电平；代表 1
- 560us 的低电平，560us 的高电平；代表 0
- `1010 0010 1100 0100 `：对应的 16 进制码为 `0x2345`；后面还有波形，没看

- 看了可以发出去，没有再详细测试


## 不带载波标准协议发送repeat 
测试命令：
- `gx_ir send_repeat_nomod 1 1`
示波器抓取波形：
![[微信图片_20250329144539.jpg]]
- 没有载波，纯粹的高低电平
- 9ms 的低电平，2.25ms 的高电平；
- 560us 的低电平

- 看了可以发出去，没有再详细测试


## 不带载波自由模式发送     
测试命令：
- `gx_ir send_ud_nomod`
示波器抓取波形：
![[微信图片_20250329144823.jpg]]

- 看了可以发出去，没有再详细测试

**需要看一下，之前好像搞错了**


## 接收载波频率和占空比       
- 用于测量载波频率和占空比
测试命令：
- `gx_ir recv_ud_carr_it`
- 万能遥控器按下按键，能够解析到频率和占空比，存在误差。芯片回复正常。



## 标准模式空闲电平 
需要修改：`gx_hal_ir_send_data_std` 函数中的配置，然后示波器或逻辑分析仪看下这个时间是否一致
- NEC 协议要求：
	- 正常情况空闲时间要为 108ms，这是完整数据帧 (含引导码、地址、命令等) 发送完毕后，到下一个数据帧开始前的间隔时间。
	- 也就是说，一个波形维持时间是 108ms
- 帧间间隔：发送完一帧之后，可以配置多长时间内忽略操作，时间到后再继续发送下一帧
- 对应的寄存器偏移为：0x50，其中的 `bit[15:8]` 用于配置，并且是**有符号位**的，所以最大的值为 127
- 延时周期以当前固定协议的 `Tm` 为单位，实际帧间延时为 `当前协议的延时 + interval_cfg`
	- 9012 协议：Tm 为 560us
	- NEC 协议：Tm 为 560us
	- RC5 协议：Tm 为 0.844ms
	- RC6 协议：Tm 为 444us
示波器抓取波形：
![[微信图片_20250329154347.jpg]]
- 配成 0：
	- 整个帧长约为 107ms 左右，其中 NEC 协议中固定的延时时间约为 `41.2ms`
![[微信图片_20250329153915.jpg]]
- 配成 127：
	- 整个帧长约为：`178.8ms`，其中空闲电平时长约为 `112.8ms`，去掉 NEC 协议中固定的延时时间约 `41.2ms`，则配置的延时时长为 `71.6ms` 左右
	- `127 * 0.56ms = 71.12ms`
	- 实际值与配置值相同




# Q&&A

## 【已解决】模拟部分用来作什么的？
- 初始化的时候会配置模拟相关的配置
- 模拟部分自己测试一下参数，然后配上
	- 广州会给一些边界值，我们再测试发送、接收是否正确


## 【已解决】标准模式带解调接收，为什么 fornax、和 sagitta、apus 参数不同？
- 因为时钟源不同，而那些参数都是基于时钟源来的，所以不同


## 【已解决】不带载波的发送或接收，红外头不是会处理载波吗？
- 发送：需要量过红外头之前的脚，看看是不是正确
- 接收：这个不需要测，因为都没有不带载波的发送头
	- 如果要测的话，需要换成机顶盒上那种板子上的红外头，黑色罩子罩住，这种头会自己把协议解调，所以发送端发送带解调的波形，红外头自己把协议解了，出来的就是不带载波的原始信息了，然后驱动再去接收，看看是不是对的数据


## 【已解决】为什么没有不带载波的接收测试？
- 我们板子上的插件是红外发送、接收一体的吗？
	- 是的
- 这个是备用功能，所以只是简单测试一下




## 【已解决】空闲电平时长指的是发送完间隔的时间吗？
![[Pasted image 20250328164208.png]]
- 是的
- 例如：NEC 协议整个周期为 108ms，前导码+命令码之类的占了 70 多 ms，后面空闲电平时间是 40ms 左右。然后继续下一帧 108ms；
	- 加了空闲电平时长之后就是 40ms + 配置的空闲电平时长


## 【已解决】遥控器如何设置？
- 长按左上角的 SET，然后按下 OK
- 输入以下对应 code，切换到对应协议后按下 EXIT 来退出
```
万能遥控器编码TV模式 
5008为RC5协议
2246为9012协议
2290为NEC协议
0020 RC6协议
```
- 需要很近距离的贴到红外管上，因为这个红外管本身是用来发送的，接收的能力很弱。

## 【已解决】引脚复用时配置了 IR_TX、IR_RX、IR_EN，实际测试时只插上了一个 2脚的发射管，这里这三个引脚如何对应？
- IR_TX
- IR_RX
- IR_EN
- 接收功能也是用的发射管，不需要将发射管的一个脚接到 IR_RX 吗？
- 板子后面还有一些模拟相关的电路，所以只需要配置好这三个引脚的引脚复用就可以




## 【已解决】接收模式时，如何用示波器或逻辑分析仪查看接收到的波形？应该接在哪里看？接在发射管的一个脚上没有波形，另一个脚上是怪怪的，如下所示

^48a1be

- 一个脚上没有波形，另一个脚上波形是怪怪的，下面这样：
![[微信图片_20250329141044.jpg]]
- 要根据原理图，量对应的位置

## 【已解决】为什么带载波自由模式发送时需要用机顶盒的板子来接收，不能用 apus 接收？

^de395a
- 可以收，可能没对准




- 如果换成自带解调的器件，应该接收能力很强吧，但是发送能力又很弱了，这样就很难同时兼容发送和接收吧？

## 【已解决】目前板子上用的是红外发射头，发送能力很强，但是接收能力很弱；如果事业部要用接收功能怎么办？
- 这种管子只能这样，如果要用接收功能，就换成接收管。发送和接收不能同时强。





## 【已解决】什么时候会使能内部模拟功能？模拟有发送和接收功能，难道还有数字发送和数字接收吗？这里的概念不太清除；
- 芯片阶段才有模拟功能部分吗？

- fpga 时外面有模拟器件，用于辅助发送和接收
- 芯片时会把模拟器件做到芯片中



## 【已解决】判决门限是如何做的？startbit、data 判决门限的值是怎么得到的？ud 模式为什么也配置 start、data 门限？
- startbit 由于 rc5、rc6 很接近，所以需要判断最短两个时间的协议
	- 如果配置门限有问题，可能导致协议识别不正确
- data 由于 nec 和 9012 很接近，所以需要判断这两个协议的 data 时间
	- 如果配置门限有问题，可能导致数据识别不正确
- 这个值是怎么得来的？
	- 芯片给 bit 的时候给的，和时钟频率相关
- ud 模式为什么也要配置 start、data 门限？
	- 不用配，配了也没用


## 【已解决】给了两种发射管，都要测试吗？
- 没有特殊原因不用测试

