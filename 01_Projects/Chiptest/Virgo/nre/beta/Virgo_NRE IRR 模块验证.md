
# 驱动
- IRR 只有接收功能，协议的解析不是靠控制器，由程序来手动解析
- 类似 sagitta ir 的自由模式
- 初始化时配置 ir 工作时钟为 1MHz，一个周期就是 1us；这样从 FIFO 中取数据的时候，每个值就代表 1us，很好计算
![[Pasted image 20250509105543.png]]

# 测试

## 测试 FIFO 门限中断   
- 默认配置 FIFO 门限为 33，用于解析 NEC 协议
- 能够识别按键，则能够正常触发中断

- v2：打开 FIFO_TEST 宏，能够触发门限中断


## 测试超时中断         
- 修改 `gx_irr.h` 中的 `CNTL_TOV` 为 `2`，系统启动跑完 irr_init 之后，会触发超时中断
- 在中断服务函数调用 `rIRR_INT(extra)` 查看中断状态，能够正常触发超时中断

- v2：默认能够触发超时中断


## 测试反转红外输入信号     
- 默认打开着反转红外输入信号，外面遥控器发出的会经过红外头，反向过后，再给到 ir 脚，因此 ir 拿到的就是反向的波形，ir 内部再反向就正常了
- 默认为开启翻转，关闭翻转后 fifo 数据会反向
	- 打开时：`fifo_data:0x8c4 0263`
	- 关闭时：`fifo_data:0x8c5 0666`
	- 高 16bit 代表整个脉冲的电平维持时间，低 16bit 代表该脉冲中高电平持续时间，确实发生了翻转



- 对于 v2 版本的红外模块，默认打开反转红外输入信号，手动配置关闭后查看 fifo 数据为反向的
	- 打开时：`fifo_data:0x67b fifo_data:0x8249`
	- 关闭时：`fifo_data:0x8661 fifo_data:0x262`

```diff
diff --git a/drivers/irr/gx_irr_v2.c b/drivers/irr/gx_irr_v2.c
index ae1f900eb..4bd3ec775 100644
--- a/drivers/irr/gx_irr_v2.c
+++ b/drivers/irr/gx_irr_v2.c
@@ -580,6 +580,7 @@ static void irr_get_fifo_data(gx_irr_extra*  extra)
 
     for(i = 0; i < fifo_num; i++) {
         fifo_data = regs->irr_fifo_data & 0xFFFF;
+       printf("fifo_data:0x%x\n", fifo_data);
        if (fifo_data & 0x8000)
                high_level = fifo_data & 0x7FFF;
        else
@@ -698,6 +699,9 @@ unsigned char irr_init(void)
     regs->irr_intr_enable |= IRR_INTR_TIMEOUT_EN;
 #endif
     regs->irr_cntl |= 1 << 9; //enable irr
+       printf("regs->irr_cntl:0x%x\n", regs->irr_cntl);
+    regs->irr_cntl &= ~(1 << 8); //enable irr
+       printf("regs->irr_cntl:0x%x\n", regs->irr_cntl);
```


## 测试 FIFO 溢出中断   
- 需要打开溢出中断，并且在 `irr_get_fifo_data` 接口中不要从 fifo 取数据，触发中断时需要清掉阈值中断
- 经过上面的操作，按下遥控器能够触发 fifo 溢出中断
```diff
diff --git a/drivers/irr/gx_irr.c b/drivers/irr/gx_irr.c
index ab1a91689..994d251fe 100644
--- a/drivers/irr/gx_irr.c
+++ b/drivers/irr/gx_irr.c
@@ -562,8 +562,10 @@ static void irr_get_fifo_data(gx_irr_extra*  extra)
     if(extra->pulse_num > IRR_MAX_PULSE_NUM )
     	extra->pulse_num = IRR_MAX_PULSE_NUM;
 
-    for(i = 0; i < extra->pulse_num; i++)
-        extra->pulse_val[i] = (uint32_t)rIRR_FIFO(extra);
+//    for(i = 0; i < extra->pulse_num; i++) {
+//        extra->pulse_val[i] = (uint32_t)rIRR_FIFO(extra);
+//	printf("pulse_val:0x%x\n", extra->pulse_val[i]);
+//	}
 }
 
 #ifdef CONFIG_ENABLE_IRQ
@@ -572,12 +574,14 @@ static enum interrupt_return irr_interrupt_isr(uint32_t vector, void* pdata)
     gx_irr_extra*  extra   = & irr_extra;
     struct irr_code_info_t irr_data;
 
+    printf("irq status:0x%x\n", rIRR_INT(extra));
    gx_mask_interrupt(vector); //mask irr irq
 
     irr_get_fifo_data(extra);
 
     IRR_INT_TIMEOUT_CLR(extra);
-    IRR_MODULE_DIS(extra);
+	IRR_INT_TRIGGER_CLR(extra);
+//    IRR_MODULE_DIS(extra);
 
     if (irr_protocol_detect(extra) < 0)
         goto exit;
@@ -594,7 +598,7 @@ static enum interrupt_return irr_interrupt_isr(uint32_t vector, void* pdata)
 
 exit:
     gx_unmask_interrupt(vector);
-    IRR_MODULE_EN(extra);
+//    IRR_MODULE_EN(extra);
 
     return HANDLED;
 }
@@ -641,7 +645,7 @@ unsigned char irr_init(void)
     sys_clk = GX_EXT_CLOCK ;
     irr_clk = 1000*1000;
 
-    rIRR_CNTL(extra) = (CNTL_TOV | CNTL_FIFOIL | CNTL_POL | CNTL_ENIR | CNTL_FIFOTM);
+    rIRR_CNTL(extra) = (CNTL_TOV | CNTL_FIFOIL | CNTL_POL | CNTL_ENIR | CNTL_FIFOTM | (1 << 2));
     IRR_DIV_SET(extra, sys_clk, irr_clk);     //set irr clock
 
     extra->algo = &gx_irr_algorithm;
diff --git a/drivers/irr/gx_irr.h b/drivers/irr/gx_irr.h
index 0c845c62f..fbe80139e 100644
--- a/drivers/irr/gx_irr.h
+++ b/drivers/irr/gx_irr.h
@@ -33,6 +33,7 @@
 #define mIRR_INT_NUM     (0x3F)
 
 #define IRR_INT_TIMEOUT_CLR(_extra_) (rIRR_INT(_extra_) |= (0x1) << bIRR_INT_FIFOTS) 
+#define IRR_INT_TRIGGER_CLR(_extra_) (rIRR_INT(_extra_) |= (0x1) << 0) 
 
 #define IRR_LEVEL_NUM_STATUS(_extra_) ((rIRR_INT(_extra_) >> bIRR_INT_NUM) & mIRR_INT_NUM)
 
```



- v2：关闭 `FIFO_TEST` 宏，关闭超时中断，打开溢出中断，不从 fifo 取数据，能够触发溢出中断
```diff
--- a/drivers/irr/gx_irr_v2.c
+++ b/drivers/irr/gx_irr_v2.c
@@ -7,7 +7,7 @@
 #include "gxhwlib_registers.h"
 #include "version_autogenerated.h"
 
-#if 0
+#if 1
 #define IRR_DBG(...)                printf( __VA_ARGS__)
 #else
 #define IRR_DBG(...)
@@ -579,19 +579,19 @@ static void irr_get_fifo_data(gx_irr_extra*  extra)
        fifo_num = 128;
 
     for(i = 0; i < fifo_num; i++) {
-        fifo_data = regs->irr_fifo_data & 0xFFFF;
-       if (fifo_data & 0x8000)
-               high_level = fifo_data & 0x7FFF;
-       else
-               low_level = fifo_data;
-       if (high_level > 0 && low_level > 0) {
-               if (pulse_num < IRR_MAX_PULSE_NUM) {
-                       extra->pulse_val[pulse_num] = high_level | ((high_level + low_level) << 16);
-                       pulse_num++;
-               }
-               high_level = 0;
-               low_level = 0;
-       }
+//        fifo_data = regs->irr_fifo_data & 0xFFFF;
+//     if (fifo_data & 0x8000)
+//             high_level = fifo_data & 0x7FFF;
+//     else
+//             low_level = fifo_data;
+//     if (high_level > 0 && low_level > 0) {
+//             if (pulse_num < IRR_MAX_PULSE_NUM) {
+//                     extra->pulse_val[pulse_num] = high_level | ((high_level + low_level) << 16);
+//                     pulse_num++;
+//             }
+//             high_level = 0;
+//             low_level = 0;
+//     }
     }
 
     extra->pulse_num = pulse_num;
@@ -695,7 +695,7 @@ unsigned char irr_init(void)
     regs->irr_fifo_ctrl = 0x7F << 16;
     regs->irr_intr_enable |= IRR_INTR_FIFO_EN;
 #else
-    regs->irr_intr_enable |= IRR_INTR_TIMEOUT_EN;
+    regs->irr_intr_enable |= IRR_INTR_OVERFLOW_EN;
 #endif
```



## 测试通用模式         
- 能够从 FIFO 寄存器中读取红外脉冲值，测试通过


## 测试通用模式解析 NEC 协议
- 能够接收遥控器发出的 NEC 波形并正确解析，测试通过




# 问题
## 【已解决】问题 1：使用 NRE A7 的 bit 无法读到键值，并且 FIFO 为空
- 查看红外接收管上的波形：有波形
- 0100 0100   1011 1011   0100 0000   1011 1111
- 4       4          b      b       4       0          b       f
![[Pasted image 20250509110109.png]]

- 用 `382541 9p_peri_newcode_FPGA_2024-09-03. tar` 是好的

- 应该不用配置引脚复用吧？是不是引脚没对应上？
	- 芯片回复接错了脚，会重新出 bit