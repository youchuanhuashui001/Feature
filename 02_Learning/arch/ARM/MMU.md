
## 参考资料
- `ARM A7 编程手册`
- `ARM A7 体系架构手册`
- `CSDN`
	- https://blog.csdn.net/zhoutaopower/article/details/114293357
	- https://blog.csdn.net/zhoutaopower/article/details/87934818
	- https://blog.csdn.net/zhoutaopower/article/details/88049623

- https://blog.csdn.net/zhoutaopower/category_8691584.html?spm=1001.2014.3001.5482
	- 包含 arm 相关处理器的博客 


## MMU 简介 

### 什么是 MMU
- `MMU`  是 `MemoryManagementUnit`  的缩写即，[内存管理](https://edu.csdn.net/cloud/houjie?utm_source=highword&spm=1001.2101.3001.7020)单元. 针对各种CPU, MMU是个可选的配件. MMU负责的是<font color=red>虚拟地址与物理地址的转换.</font> 提供硬件机制的[内存](https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020)访问授权.（现代 CPU 的应用中，基本上都选择了使用 MMU）


### MMU 的产生 
- 许多年以前，当人们还在使用DOS或是更古老的操作系统的时候，计算机的内存还非常小，一般都是以K为单位进行计算，相应的，当时的程序规模也不大，所以内存容量虽然小，但还是可以容纳当时的程序。但随着图形界面的兴起还用[用户需求](https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&spm=1001.2101.3001.7020)的不断增大，应用程序的规模也随之膨胀起来，终于一个难题出现在程序员的面前，那就是<font color=green>应用程序太大以至于内存容纳不下该程序，通常解决的办法是把程序分割成许多称为覆盖块（overlay）的片段。覆盖块0首先运行，结束时他将调用另一个覆盖块。</font>虽然覆盖块的交换是由OS完成的，但是必须先由程序员把程序先进行分割，这是一个费时费力的工作，而且相当枯燥。人们必须找到更好的办法从根本上解决这个问题。不久人们找到了一个办法，这就是虚拟存储器(virtual memory).<font color=green>虚拟存储器的基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上比如对一个16MB的程序和一个内存只有4MB的机器，OS通过选择，可以决定各个时刻将哪4M的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。</font>而这个16M的程序在运行前不必由程序员进行分割


### MMU 的作用 
1. 将虚拟地址翻译成物理地址，然后访问实际的物理地址
2. 访问权限控制 



### MMU 工作过程 
- MMU 进行虚拟地址转换成为物理地址的过程是 MMU 工作的核心
- 大多数使用虚拟存储器的系统都使用一种称为分页（paging）。<font color=green>虚拟地址空间划分成称为页（page）的单位</font>，而<font color=green>相应的物理地址空间也被进行划分，单位是页框(frame).</font> **页和页框的大小必须相同。** 接下来配合图片我以一个例子说明页与页框之间在MMU的调度下是如何进行映射的：
![[Pasted image 20241213155409.png]]

- **例1:**  
	-  `MOVE REG,0 //将0号地址的值传递进寄存器REG` 
	- 虚拟地址0将被送往MMU,MMU看到该虚地址落在页0范围内（页0范围是0到4095），从上图我们看到页0所对应（映射）的页框为2（页框2的地址范围是8192到12287），因此MMU将该虚拟地址转化为物理地址8192，并把地址8192送到地址总线上。内存对MMU的映射一无所知，它只看到一个对地址8192的读请求并执行它。MMU从而把0到4096的虚拟地址映射到8192到12287的物理地址。
- **例2：**  
	- `MOVE REG,8192   --> MOVE REG,24576`  `
	- 因为虚拟地址8192在页2中，而页2被映射到页框6（物理地址从24576到28671）
- **例3：**  
	-  `MOVE REG,20500 --> MOVE REG,12308
	- 虚拟地址20500在虚页5（虚拟地址范围是20480到24575）距开头20个字节处，虚页5映射到页框3（页框3的地址范围是 12288到16383），于是被映射到物理地址12288+20=12308。

通过适当的设置MMU，可以把16个虚页隐射到8个页框中的任何一个，但是这个方法并没有有效的解决虚拟地址空间比物理地址空间大的问题。从上图中我们可以看到，我们只有8个页框（物理地址），但我们有16个页（虚拟地址），所以我们只能把16个页中的8个进行有效的映射。


- **例4：**
	- `MOV REG,32780` 
	- 虚拟地址32780落在页8的范围内，从上图总我们看到页8没有被有效的进行映射（该页被打上X），这是又会发生什么？MMU注意到这个页没有被映射，于是通知CPU发生一个**缺页故障（page fault）**.这种情况下操作系统必须处理这个页故障，它必须从8个物理页框中找到1个当前很少被使用的页框并把该页框的内容写入外围存储器（这个动作被称为page copy），随后把需要引用的页（例4中是页8）映射到刚才释放的页框中（这个动作称为修改映射关系），然后从新执行产生故障的指令（MOV REG,32780）。假设操作系统决定释放页框1，那么它将把虚页8装入物理地址的4-8K,并做两处修改：首先把标记虚页1未被映射（原来虚页1是被影射到页框1的），以使以后任何对虚拟地址4K到8K的访问都引起页故障而使操作系统做出适当的动作（这个动作正是我们现在在讨论的），其次他把虚页8对应的页框号由X变为1，因此重新执行MOV REG,32780时，MMU将把32780映射为4108。
	- <font color=green>当虚拟地址没有被映射的时候，首先会产生一个缺页故障，操作系统处理这个缺页故障的时候会根据最少使用原则将实际的物理页踢出去一个，然后将虚拟地址映射到这个物理页，再回去执行产生缺页故障的那条指令 </font>




- 首先明确一点，MMU 的主要工作只有一个：**将虚拟地址映射到物理地址**
- 举例：虚拟地址 `1026 (十进制)`  如何找到对应物理地址 
![[Pasted image 20241213164407.png]]



### MMU 的页表和 TLB
- 页表：
	- 由上面的例子可知，在 MMU 工作的时候，软件也需要进行配合，软件需要准备一张表，来告诉 MMU 当前的地址映射的关系（即，虚拟地址和物理地址的对应关系）。
	- 这张表存储在内存中（代码的数据结构），每次 MMU 工作的时候，都去遍历这个表里面的关系，然后找到对应的映射，这个过程叫做 table walk。
- TBL：
	- 为了加速页表的访问，所以有了 `TLB`，这是一个 `table` 专用的 `cache`

为了减少存储器访问的平均消耗， 转换表遍历结果被高速缓存在一个或多个叫作 Translation Lookaside Buffers(TLBs)的结构中。通常在ARM 的实现中每个内存接口有一个TLB。当存储器中的转换表被改变或选中了不同的转换表(通过写CP15 的寄存器，先前高速缓存的转换表遍历结果将不再有效。MMU 结构提供了刷新TLB 的操作。MMU 结构也允许特定的转换表遍历结果被锁定在一个TLB 中，这就保证了对相关的存储器区域的访问绝不会导致转换表遍历，这也对那些把指令和数据锁定在高速缓存中的实时代码有相同的好处。

当ARM 要访问存储器时，MMU 先查找 TLB 中的虚拟地址表，如果没有命中，则，还是要去走 table walk 的流程。即，如果TLB 中没有虚拟地址的入口，则转换表遍历硬件从存在主存储器中的转换表中获取转换和访问权限。一旦取到，这些信息将被放在 TLB 中，它会放在一个没有使用的入口处或覆盖一个已有的入口。





## WTF

### PL1




### DCISW
- `CP15` 的某个寄存器，通过 `mcr p15, 0, r2, c7, c, 2` 来操作 
- `32-bit WO Data cache invalidate by set/way`
![[Pasted image 20241213154904.png]]



